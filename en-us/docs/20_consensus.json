{
  "filename": "20_consensus.md",
  "__html": "<h1>1. Introduction</h1>\n<p>Tensority alogrithm utilizes seed and block header hash as input and generate work correspondingly. Seed is a byte array of 32 determined by a period of blockchain history. In other word, seed can be considered as a snapshot of historical network consensus. To get a validated block, miners should keep operating Tensority with different nonce until matching the requirement of difficulty.</p>\n<h1>2. Algorithm Procedure</h1>\n<p>There are mainly five procedures of Tensority:</p>\n<ul>\n<li>cache calculation</li>\n<li>matrix construction</li>\n<li>matrix operation</li>\n<li>work generation</li>\n<li>work validation</li>\n</ul>\n<h2>2.1. Cache Calculation</h2>\n<p>Cache is generated by seed. Compared with block rate, seed renewal is slower. So, cache generated from seed can be reused for a period of time. Furthermore, cache is the intermediary of constructing cache matrix. The main steps are listed as follow:</p>\n<p><strong>1. Seed Extention</strong></p>\n<p>Set seed_0 as seed, calculate sha256 hash of seed_0 and then we get seed_1. Similarly, We can get seed_i one after another by calculating sha256 hash of seed_i−1. Finally, we string seed_0, . . . , seed_extround together and get extseed.</p>\n<p><strong>2. Scrypt Extseed</strong></p>\n<p>We recursively call Scrypt function to obtain the cache, an unint32 array of 32x1024x128. Scrypt is a kind of KDF alogrithm mainly used as key generation method aimed at preventing low-cost password collision. It is worth to mentioned that Scrypt is used in Litecoin since 2011. So, it has been proved as a reliable seed extension algorithm.</p>\n<pre><code class=\"language-txt\">Algorithm: calcSeedCache\n------------------------------------------------\nInput: seed\nOutput: cache\n------------------------------------------------\n1   Initialize extround = 3, scryptround = 128;\n2   extseed = seed;\n3   tmphash = seed;\n4   for i = 1; i &lt;= extround; i++ do\n5       tmphash = SHA256(tmphash);\n6       extseed = append(extseed, tmphash);\n7   end\n8   cache = null;\n9   tmpv = null;\n10  for j = 1; j &lt;= scryptround; j++ do\n11      tmpv = Scrypt.smix(extseed, tmpv);\n12      cache = append(cache, tmpv);\n13  end\n14  return cache\n------------------------------------------------\n</code></pre>\n<h2>2.2  Matrix Construction</h2>\n<p>Technical innovation of Tensority is based on tensor and matrix operations. In this procedure, we construct matrices which are ready for matrix operations in the next procedure. The main steps are listed as follow:</p>\n<p><strong>1. Cache Recomposition</strong></p>\n<p>The design of recomposition method is aimed at improving efficiency of ASCI mining machines, such as faster memory accession. Considering data alignment and memory access of miners, we design following recomposition of cache.</p>\n<p>At the begining, we partition cache into 128 groups. Each group includes 32x1024 elements. In each group, we cluster 32 elements as a unit. So, we obtain an uint32 matrix <strong>tmpmatrix</strong> of 32x1024x128. The size of <strong>recomposedmatrix</strong> is also 32x1024x128. <strong>Tmpmatrix</strong> elements with odd dimension 2 index equal <strong>recomposedmatrix</strong> to elements with dimension2 index from 1 to 1024/2 correspondingly. Similarly, <strong>tmpmatrix</strong> elements with even index are corespondent to <strong>recomposedmatrix</strong> elements with index from 1024/2+1 to 1024.</p>\n<p><strong>2. Cache Matrix Construction</strong></p>\n<p>Spread matrix <strong>recomposedmatrix</strong> and set it as a int8 array of 256x256x256. Then we get a float64 array of 256x256x256 by type casting. Finally, we obtain a float64 matrix <strong>cachematrix</strong> of 256x256x256.</p>\n<pre><code class=\"language-txt\">Algorithm: constructCacheMatrix\n------------------------------------------------------------------------------\nInput: cache\nOutput: cachematrix\n------------------------------------------------------------------------------\n1   Initialize dim1 = 32; dim2 = 1024; dim3 = 128; dim = 256;\n2   tmpmatrix = Matrix(cache, dim1, dim2, dim3);\n3   recomposedmatrix = NewMatrix(dim1, dim2, dim3);\n4   cachematrix = NewMatrix(dim, dim, dim);\n5   recomposedmatrix[:][1:dim2/2][:] = tmpmatrix[:][all odd index][:];\n6   recomposedmatrix[:][dim2/2+1:dim2][:] = tmpmatrix[:][all even index][:];\n7   cachematrix = Float64(Matrix(Int8Array(recomposedmatrix), dim, dim, dim)));\n8   return cachematrix;\n------------------------------------------------------------------------------\n</code></pre>\n<h2>2.3 Matrix Operation</h2>\n<p>The rate of matrix operation mainly depends on the computing power of miner. In addition, float64 matrix multiplication instead of integer multiplication is adopted because we should enable miners supporting AI algorithms which mainly run under float type environment.The procedure of matrix operation utilizes block header hash <strong>headerhash</strong> as a index to slice <strong>cachematrix</strong>, an float64 matrix of 256x256x256. After calculating matrix multiplication with slices iteratively for several round, we finally obtain the work matrix <strong>workmatrix</strong>. Note that there are total 256 rounds of multiplication between matrices of 256x256. The main steps are listed as follow:</p>\n<p><strong>1. Generate Index of Matrix Slices</strong></p>\n<p>We divide block header hash into 4 group first. Then we operate SHA256 to each group and obtain corresponding sequence of 32 bytes. Each byte in sequence is casted to integer as the index of the matrix slice. Obviously, 4x32 matrix slices are generated during this procedure.</p>\n<p><strong>2. Matrix Caculation</strong></p>\n<p>We can obtain the corresponding 256x256 <strong>cachematrix</strong> matrix slice <strong>mb</strong> according to the slice index. Matrix <strong>mc</strong> is the result of multiplication of <strong>ma</strong> and <strong>mbT</strong>. Note that <strong>ma</strong> is initialized to identity matrix in the first round. Then we cast elements of <strong>mc</strong> to int32.</p>\n<p>Here we define a operation called <strong>Compress32to8</strong>. It converts the data type int32 of data b = (b_1, b_2, b_3, b_4) (big endian) into uint8 via the formula (b_3 + b_4) mod (2^8). Compress32to8 is introduced to ensure better randomness of multiplication result.</p>\n<p>After that, we set <strong>mc</strong> elements as their corresponding Compress32to8 results. Then we cast <strong>mc</strong> elements to float64 and assign the result to <strong>ma</strong> until sequence run out eventually. Previous steps should be iterated for 2 times.</p>\n<p>Finally, we utilize <strong>ma</strong> to renew <strong>hashmatrix</strong>. We will get Integer32 sum of <strong>ma</strong> and <strong>hashmatrix</strong>. Renew <strong>hashmatrix</strong> element with low 8 bits value in that position and cast the element to float64.</p>\n<pre><code class=\"language-txt\">Algorithm: constructHashMatrix\n------------------------------------------------------------------------------\nInput: cachematrix, headerhash\nOutput: hashmatrix\n------------------------------------------------------------------------------\n1   Initialize drawround = 4; mulround = 2; dim = 256;\n2   hashmatrix = Matrix(dim, dim);\n3   drawmatrix = Matrix(headerhash, drawround, sizeof(headerhash)/drawround);\n4   for i = 1; i &lt;= drawround; i++ do\n5       ma = I;\n6       mc = Matrix(dim, dim);\n7       sequence = SHA256(drawmatrix[i]);\n8       for j = 1; j &lt;= mulround; j++ do\n9           for k = 1; k &lt;= sizeof(sequence); k++ do\n10              index = uint8(sequence[k])+1;\n11              mb = srcmatrix[index][:][:];\n12              mc = ma * mb.T();\n13              for element ∈ mc do\n14                  element = Float64(Compress32to8(Int32(element)));\n15              end\n16              ma = mc\n17          end\n18      end\n19      for row = 1; row &lt;= dim; row++ do\n20          for col = 1; col &lt;= dim; col++ do\n21              i32vhashmatrix = Int32(hashmatrix[row][col]);\n22              i32vma = Int32(ma[row][col]);\n23              i8v = Int8(i32vhashmatrix+i32vma);\n24              hashmatrix[row][col] = Float64(i8v);\n25          end\n26      end\n27  end\n28  return hashmatrix;\n------------------------------------------------------------------------------\n</code></pre>\n<h2>2.4 Work Generation</h2>\n<p>Work generation algorithm use <strong>hashmatrix</strong> as input and generation 32 bytes hash representing work. The key of that procedure is improving computational efficiency under the premise of randomness. So, we utilize <strong>FNV</strong> enabling faster hash to hash matrix instead of <strong>SH2</strong> or <strong>SH3</strong> because it is a non-cryptographic hash algorithm. FNV has also been adopted in Ethereum Ethash for a while. So, its reliability has been proved. In addition, We choose 0x01000193 as parameter <em>FNV prime</em>. Finally, we apply SHA256 to the result of FNV to assure solid randomness.</p>\n<p><strong>1. Resize Matrix Hashmatrix</strong></p>\n<p>Hashmatrix is an uint8 matrix of 256x256. For each row, extract elements with same remainder from dividing 64 by the position as a group. Combine elements in each group into an unint32 element. Then we get an unint32 matrix of 256x64 called <strong>mat32</strong>.</p>\n<p><strong>2. Binary Forwarded FNV</strong></p>\n<p>Binary Forwarded FNV is essentially a method to hash matrix. First, we initiate n to dim1 of mat32. For row 1 to row n, operate FNV function to two element in same column with same remainder from dividing n/2 by the row position and set that element with lower row index as FNV result. Then we half n and execute that step unit n equals to 1. Finally, we take the first row of mat32 and convert it to byte array. After operate SHA256 to that byte array, we obtain <strong>work</strong>.</p>\n<pre><code class=\"language-txt\">Algorithm: Binary Forwarded FNV\n---------------------------------------------------------------\nInput: mat32\nOutput: hash\n---------------------------------------------------------------\n1   Initialize dim1 = 256; dim2 = 64;\n2   for k = dim1; k &gt; 1; k = k/2 do\n3       for i = 1; i &lt;= k; i++ do\n4           for j = 1; j &lt;= dim2; j++ do\n5               mat32[i][j] = FNV(mat32[i][j], mat32[i+k][j]);\n6           end\n7       end\n8   end\n9   hash = SHA256(ToByteArray(mat32[0][:]);\n10  return hash;\n---------------------------------------------------------------\n</code></pre>\n<h2>2.5 Work Validation</h2>\n<p>In this procedure, we compare work value with block difficulty. If the work have lower value, it can be seen as a validated work and miners will broadcast that block before receiving a validated block from others. Otherwise, miners will keep changing nonce value to execute Tensority before receiving a validated block.</p>\n<h1>3. Random Analysis of Tensority</h1>\n<p><a href=\"https://github.com/Bytom/bytom/wiki/download/tensority-v1.2.pdf\">Tensority White Paper</a> is a good reference.</p>\n",
  "link": "/en-us/docs/20_consensus.html",
  "meta": {}
}