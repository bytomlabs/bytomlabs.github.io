{
  "filename": "21、_p2p.md",
  "__html": "<h1>nodes</h1>\n<p>A Bytom P2P network has different kinds of nodes with different requirements for connectivity to one another.\nThis document describes what kind of nodes should enable and how they should work.</p>\n<h2>Seeds</h2>\n<p>Seeds are the first point of contact for a new node.\nThe new node discovers other nodes in the network through seeds.</p>\n<h2>New Full Node</h2>\n<p>The full node saves the complete data on the chain.\nA new node needs a few things to connect to the network:</p>\n<ul>\n<li>a list of seeds, which can be provided to Bytom via config file or command flags.</li>\n<li>a <code>ChainID</code>, also called <code>Network</code> at the p2p layer.</li>\n<li>a recent block height, H, and hash, HASH for the blockchain.</li>\n</ul>\n<p>With the above, the node then queries some peers from the discovery service, dials those peers, and runs the net<br>\nsync protocols with those it successfully connects to.</p>\n<h2>Vault Mode Node</h2>\n<p>Node runs in an offline environment. Can be used to sign a transaction, but can't broadcast a transaction.</p>\n<h1>Node Discovery Protocol</h1>\n<p>This specification defines the Node Discovery protocol, a Kademlia-like DHT that\nstores information about Bytom nodes. The Kademlia structure was chosen because it yields a topology of low diameter.</p>\n<h2>Node Identities</h2>\n<p>Every node has a cryptographic identity, a key on the Ed25519. The public\nkey of the node serves as its identifier or 'node ID'.</p>\n<p>The 'distance' between two node IDs is the bitwise exclusive or on the hashes of the\npublic keys, taken as the number.</p>\n<pre><code class=\"language-text\">distance(n₁, n₂) = keccak256(n₁) XOR keccak256(n₂)\n</code></pre>\n<h2>Node Table</h2>\n<p>Nodes in the Discovery Protocol keep information about other nodes in their neighborhood.\nNeighbor nodes are stored in a routing table consisting of 'k-buckets'. For each <code>0 ≤ i &lt; 256</code>, every node keeps a k-bucket for nodes of distance between <code>2i</code> and <code>2i+1</code> from\nitself.</p>\n<p>The Node Discovery Protocol uses <code>k = 16</code>, i.e. every k-bucket contains up to 16 node\nentries. The entries are sorted by time last seen — least-recently seen node at the head,\nmost-recently seen at the tail.</p>\n<p>Whenever a new node N₁ is encountered, it can be inserted into the corresponding bucket.\nIf the bucket contains less than <code>k</code> entries N₁ can simply be added as the first entry. If\nthe bucket already contains <code>k</code> entries, the least recently seen node in the bucket, N₂,\nneeds to be revalidated by sending a ping packet. If no reply is received from N₂ it is\nconsidered dead, removed and N₁ added to the front of the bucket.</p>\n<h2>Recursive Lookup</h2>\n<p>A 'lookup' locates the <code>k</code> closest nodes to a node ID.</p>\n<p>The lookup initiator starts by picking <code>α</code> closest nodes to the target it knows of. The\ninitiator then sends concurrent FindNode packets to those nodes. <code>α</code> is a system-wide\nconcurrency parameter, such as 3. In the recursive step, the initiator resends FindNode to\nnodes it has learned about from previous queries. Of the <code>k</code> nodes the initiator has heard\nof closest to the target, it picks <code>α</code> that it has not yet queried and resends FindNode to\nthem. Nodes that fail to respond quickly are removed from consideration until and unless\nthey do respond.</p>\n<p>If a round of FindNode queries fails to return a node any closer than the closest already\nseen, the initiator resends the find node to all of the <code>k</code> closest nodes it has not\nalready queried. The lookup terminates when the initiator has queried and gotten responses\nfrom the <code>k</code> closest nodes it has seen.</p>\n<h2>Wire Protocol</h2>\n<p>Node discovery messages are sent as UDP datagrams. The maximum size of any packet is 1280\nbytes.</p>\n<pre><code class=\"language-text\">packet = packet-header || packet-data\n</code></pre>\n<p>Every packet starts with a header:</p>\n<pre><code class=\"language-text\">packet-header = hash || signature || packet-type\nhash = keccak256(signature || packet-type || packet-data)\nsignature = sign(packet-type || packet-data)\n</code></pre>\n<p>The <code>hash</code> exists to make the packet format recognizable when running multiple protocols\non the same UDP port. It serves no other purpose.</p>\n<p>Every packet is signed by the node's identity key. The <code>signature</code> is encoded as a byte\narray of length 65 as the concatenation of the signature values <code>r</code>, <code>s</code> and the 'recovery\nid' <code>v</code>.</p>\n<p>The <code>packet-type</code> is a single byte defining the type of message. Valid packet types are\nlisted below. Data after the header is specific to the packet type and is encoded as an\nRLP list. As per EIP-8, implementations should ignore any additional elements in the list\nas well as any extra data after the list.</p>\n<h3>Ping Packet (0x01)</h3>\n<pre><code class=\"language-text\">packet-data = [version, from, to, expiration]\nversion = 4\nfrom = [sender-ip, sender-udp-port, sender-tcp-port]\nto = [recipient-ip, recipient-udp-port, 0]\n</code></pre>\n<p>The <code>expiration</code> field is an absolute UNIX time stamp. Packets containing a time stamp\nthat lies in the past are expired may not be processed.</p>\n<p>When a ping packet is received, the recipient should reply with a pong packet. It may also\nconsider the sender for addition into the node table.</p>\n<h3>Pong Packet (0x02)</h3>\n<pre><code class=\"language-text\">packet-data = [to, ping-hash, expiration]\n</code></pre>\n<p>Pong is the reply to ping.</p>\n<p><code>ping-hash</code> should be equal to <code>hash</code> of the corresponding ping packet. Implementations\nshould ignore unsolicited pong packets that do not contain the hash of the most recent\nping packet.</p>\n<h3>FindNode Packet (0x03)</h3>\n<pre><code class=\"language-text\">packet-data = [target, expiration]\n</code></pre>\n<p>A FindNode packet requests information about nodes close to <code>target</code>. The <code>target</code> is a\nEd25519 public key. When FindNode is received, the recipient should reply with\nneighbors packets containing the closest 16 nodes to target found in its local table.</p>\n<h3>Neighbors Packet (0x04)</h3>\n<pre><code class=\"language-text\">packet-data = [nodes, expiration]\nnodes = [[ip, udp-port, tcp-port, node-id], ... ]\n</code></pre>\n<p>Neighbors is the reply to FindNode.</p>\n<h1>P2P Multiplex Connection</h1>\n<h2>MConnection</h2>\n<p><code>MConnection</code> is a multiplex connection that supports multiple independent streams\nwith distinct quality of service guarantees atop a single TCP connection.\nEach stream is known as a <code>Channel</code> and each <code>Channel</code> has a globally unique <em>byte id</em>.\nEach <code>Channel</code> also has a relative priority that determines the quality of service\nof the <code>Channel</code> compared to other <code>Channel</code>s.\nThe <em>byte id</em> and the relative priorities of each <code>Channel</code> are configured upon\ninitialization of the connection.</p>\n<p>The <code>MConnection</code> supports three packet types:</p>\n<ul>\n<li>Ping</li>\n<li>Pong</li>\n<li>Msg</li>\n</ul>\n<h3>Ping and Pong</h3>\n<p>The ping and pong messages consist of writing a single byte to the connection; 0x1 and 0x2, respectively.</p>\n<p>When we haven't received any messages on an <code>MConnection</code> in time <code>pingTimeout</code>, we send a ping message.\nWhen a ping is received on the <code>MConnection</code>, a pong is sent in response.</p>\n<p>If a pong or message is not received in sufficient time after a ping, the peer is disconnected from.</p>\n<h3>Msg</h3>\n<p>Messages in channels are chopped into smaller <code>msgPacket</code>s for multiplexing.</p>\n<pre><code>type msgPacket struct {\n\tChannelID byte\n\tEOF       byte // 1 means message ends here.\n\tBytes     []byte\n}\n</code></pre>\n<p>The <code>msgPacket</code> is serialized using <a href=\"https://github.com/Bytom/bytom/tree/master/vendor/github.com/tendermint/go-wire\">go-wire</a> and prefixed with 0x3.\nThe received <code>Bytes</code> of a sequential set of packets are appended together\nuntil a packet with <code>EOF=1</code> is received, then the complete serialized message\nis returned for processing by the <code>onReceive</code> function of the corresponding channel.</p>\n<h3>Multiplexing</h3>\n<p>Messages are sent from a single <code>sendRoutine</code>, which loops over a select statement and results in the sending\nof a ping, a pong, or a batch of data messages. The batch of data messages may include messages from multiple channels.\nMessage bytes are queued for sending in their respective channel, with each channel holding one unsent message at a time.\nMessages are chosen for a batch one at a time from the channel with the lowest ratio of recently sent bytes to channel priority.</p>\n<h2>Sending Messages</h2>\n<p>There are two methods for sending messages:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(m MConnection)</span> <span class=\"hljs-title\">Send</span><span class=\"hljs-params\">(chID <span class=\"hljs-keyword\">byte</span>, msg <span class=\"hljs-keyword\">interface</span>{})</span> <span class=\"hljs-title\">bool</span></span> {}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(m MConnection)</span> <span class=\"hljs-title\">TrySend</span><span class=\"hljs-params\">(chID <span class=\"hljs-keyword\">byte</span>, msg <span class=\"hljs-keyword\">interface</span>{})</span> <span class=\"hljs-title\">bool</span></span> {}\n</code></pre>\n<p><code>Send(chID, msg)</code> is a blocking call that waits until <code>msg</code> is successfully queued\nfor the channel with the given id byte <code>chID</code>.  The message <code>msg</code> is serialized\nusing the <code>tendermint/wire</code> submodule's <code>WriteBinary()</code> reflection routine.</p>\n<p><code>TrySend(chID, msg)</code> is a nonblocking call that queues the message msg in the channel\nwith the given id byte chID if the queue is not full; otherwise it returns false immediately.</p>\n<p><code>Send()</code> and <code>TrySend()</code> are also exposed for each <code>Peer</code>.</p>\n<h2>Peer</h2>\n<p>Each peer has one <code>MConnection</code> instance, and includes other information such as whether the connection\nwas outbound, whether the connection should be recreated if it closes, various identity information about the node,\nand other higher level thread-safe data used by the reactors.</p>\n<h2>Switch/Reactor</h2>\n<p>The <code>Switch</code> handles peer connections and exposes an API to receive incoming messages\non <code>Reactors</code>.  Each <code>Reactor</code> is responsible for handling incoming messages of one\nor more <code>Channels</code>.  So while sending outgoing messages is typically performed on the peer,\nincoming messages are received on the reactor.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// Declare a MyReactor reactor that handles messages on MyChannelID.</span>\n<span class=\"hljs-keyword\">type</span> MyReactor <span class=\"hljs-keyword\">struct</span>{}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(reactor MyReactor)</span> <span class=\"hljs-title\">GetChannels</span><span class=\"hljs-params\">()</span> []*<span class=\"hljs-title\">ChannelDescriptor</span></span> {\n    <span class=\"hljs-keyword\">return</span> []*ChannelDescriptor{ChannelDescriptor{ID:MyChannelID, Priority: <span class=\"hljs-number\">1</span>}}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(reactor MyReactor)</span> <span class=\"hljs-title\">Receive</span><span class=\"hljs-params\">(chID <span class=\"hljs-keyword\">byte</span>, peer *Peer, msgBytes []<span class=\"hljs-keyword\">byte</span>)</span></span> {\n    r, n, err := bytes.NewBuffer(msgBytes), <span class=\"hljs-built_in\">new</span>(<span class=\"hljs-keyword\">int64</span>), <span class=\"hljs-built_in\">new</span>(error)\n    msgString := ReadString(r, n, err)\n    fmt.Println(msgString)\n}\n\n<span class=\"hljs-comment\">// Other Reactor methods omitted for brevity</span>\n...\n\n<span class=\"hljs-keyword\">switch</span> := NewSwitch([]Reactor{MyReactor{}})\n\n...\n\n<span class=\"hljs-comment\">// Send a random message to all outbound connections</span>\n<span class=\"hljs-keyword\">for</span> _, peer := <span class=\"hljs-keyword\">range</span> <span class=\"hljs-keyword\">switch</span>.Peers().List() {\n    <span class=\"hljs-keyword\">if</span> peer.IsOutbound() {\n        peer.Send(MyChannelID, <span class=\"hljs-string\">\"Here's a random message\"</span>)\n    }\n}\n</code></pre>\n<h1>Peers</h1>\n<p>This document explains how Bytom Peers are identified and how they connect to one another.</p>\n<h2>Peer Identity</h2>\n<p>Bytom peers are expected to maintain long-term persistent identities in the form of a public key.\nEach peer has an ID defined as <code>peer.PubKey == privKey.PubKey().Unwrap().(crypto.PubKeyEd25519)</code>.</p>\n<p>When attempting to connect to a peer, we use the PeerURL: <code>&lt;ID&gt;@&lt;IP&gt;:&lt;PORT&gt;</code>.\nWe will attempt to connect to the peer at IP:PORT, and verify,\nvia authenticated encryption, that it is in possession of the private key\ncorresponding to <code>&lt;ID&gt;</code>. This prevents man-in-the-middle attacks on the peer layer.</p>\n<h2>Connections</h2>\n<p>All p2p connections use TCP.\nUpon establishing a successful TCP connection with a peer,\ntwo handhsakes are performed: one for authenticated encryption, and one for versioning.\nBoth handshakes have configurable timeouts (they should complete quickly).</p>\n<h3>Authenticated Encryption Handshake</h3>\n<p>System implements the Station-to-Station protocol\nusing ED25519 keys for Diffie-Helman key-exchange and NACL SecretBox for encryption.\nIt goes as follows:</p>\n<ul>\n<li>generate an emphemeral ED25519 keypair</li>\n<li>send the ephemeral public key to the peer</li>\n<li>wait to receive the peer's ephemeral public key</li>\n<li>compute the Diffie-Hellman shared secret using the peers ephemeral public key and our ephemeral private key</li>\n<li>generate two nonces to use for encryption (sending and receiving) as follows:\n<ul>\n<li>sort the ephemeral public keys in ascending order and concatenate them</li>\n<li>RIPEMD160 the result</li>\n<li>append 4 empty bytes (extending the hash to 24-bytes)</li>\n<li>the result is nonce1</li>\n<li>flip the last bit of nonce1 to get nonce2</li>\n<li>if we had the smaller ephemeral pubkey, use nonce1 for receiving, nonce2 for sending;\nelse the opposite</li>\n</ul>\n</li>\n<li>all communications from now on are encrypted using the shared secret and the nonces, where each nonce\nincrements by 2 every time it is used</li>\n<li>we now have an encrypted channel, but still need to authenticate</li>\n<li>generate a common challenge to sign:\n<ul>\n<li>SHA256 of the sorted (lowest first) and concatenated ephemeral pub keys</li>\n</ul>\n</li>\n<li>sign the common challenge with our persistent private key</li>\n<li>send the go-wire encoded persistent pubkey and signature to the peer</li>\n<li>wait to receive the persistent public key and signature from the peer</li>\n<li>verify the signature on the challenge using the peer's persistent public key</li>\n</ul>\n<p>If this is an outgoing connection (we dialed the peer) and we used a peer ID,\nthen finally verify that the peer's persistent public key corresponds to the peer ID we dialed,\nie. <code>peer.PubKey.Address() == &lt;ID&gt;</code>.</p>\n<p>The connection has now been authenticated. All traffic is encrypted.</p>\n<p>Note: only the dialer can authenticate the identity of the peer,\nbut this is what we care about since when we join the network we wish to\nensure we have reached the intended peer (and are not being MITMd).</p>\n<h3>Peer Filter</h3>\n<p>Before continuing, we check if the new peer has the same ID as ourselves or\nan existing peer. If so, we disconnect.</p>\n<p>We also check the peer's address and public key against\nan blacklist - If the node is in the blacklist, the connection is prohibited for 24 hours.</p>\n<h3>Version Handshake</h3>\n<p>The Tendermint Version Handshake allows the peers to exchange their NodeInfo:</p>\n<pre><code class=\"language-golang\"><span class=\"hljs-keyword\">type</span> NodeInfo <span class=\"hljs-keyword\">struct</span> {\n  PubKey     crypto.PubKeyEd25519\n  ListenAddr <span class=\"hljs-keyword\">string</span>\n  Network    <span class=\"hljs-keyword\">string</span>\n  Version    <span class=\"hljs-keyword\">string</span>\n  Moniker    <span class=\"hljs-keyword\">string</span>\n  Other      []<span class=\"hljs-keyword\">string</span>\n}\n</code></pre>\n<p>The connection is disconnected if:</p>\n<ul>\n<li><code>peer.NodeInfo.Version</code> is not formatted as <code>X.X.X</code> where X are integers known as Major, Minor, and Revision</li>\n<li><code>peer.NodeInfo.Version</code> Major is not the same as ours</li>\n<li><code>peer.NodeInfo.Network</code> is not the same as ours</li>\n</ul>\n<p>At this point, if we have not disconnected, the peer is valid.\nIt is added to the switch and hence all reactors via the <code>AddPeer</code> method.\nNote that each reactor may handle multiple channels.</p>\n<h2>Connection Activity</h2>\n<p>Once a peer is added, incoming messages for a given reactor are handled through\nthat reactor's <code>Receive</code> method, and output messages are sent directly by the Reactors\non each peer. A typical reactor maintains per-peer go-routine(s) that handle this.</p>\n",
  "link": "/en-us/docs/21、_p2p.html",
  "meta": {}
}