<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="21、_p2p" />
	<meta name="description" content="21、_p2p" />
	<!-- 网页标签标题 -->
	<title>21、_p2p</title>
	<link rel="shortcut icon" href="/img/docsite.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/en-us/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">中</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/en-us/index.html" target="_self">HOME</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/en-us/docs/demo1.html" target="_self">DOCS</a></li><li class="menu-item menu-item-normal"><a href="/en-us/blog/index.html" target="_self">BLOG</a></li><li class="menu-item menu-item-normal"><a href="/en-us/community/index.html" target="_self">COMMUNITY</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>Document</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>Understanding Bytom</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/en-us/docs/mydoc_index.html" target="_self">Overview</a></li><li style="height:324px;overflow:hidden" class="menu-item menu-item-level-2"><span>Architecture and Design<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/en-us/docs/12_architecture_overview.html" target="_self">Overall Architecture Overview</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/13_key.html" target="_self">Key</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/14_address.html" target="_self">Address</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/15_account.html" target="_self">Account</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/16_transaction.html" target="_self">Transaction</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/18_block.html" target="_self">Block</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/17_UTXO.html" target="_self">UTXO</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/19_p2p.html" target="_self">P2p Network</a></li></ul></li><li style="height:108px;overflow:hidden" class="menu-item menu-item-level-2"><span>Consensus<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/en-us/docs/18_consensus.html" target="_self">Overvew</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">Design Principle</a></li></ul></li><li style="height:180px;overflow:hidden" class="menu-item menu-item-level-2"><span>Smart Contract<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/en-us/docs/20_smart_contract_overview.html" target="_self">Overview</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/21_smart_contract_build.html" target="_self">Smart Contract Build</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/22_contract_operator.html" target="_self">Contract Template</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/22_contract_template.html" target="_self">Contract Template</a></li></ul></li><li style="height:108px;overflow:hidden" class="menu-item menu-item-level-2"><span>Side Chain<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo1.html" target="_self">Overview</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">Configuration Node</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>Developer Guilde</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/en-us/docs/06_build_environment.html" target="_self">Build Developer Environment</a></li><li style="height:108px;overflow:hidden" class="menu-item menu-item-level-2"><span>Compile and Run Node<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/en-us/docs/07_compile_and_run_node.html" target="_self"></a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">docker run node</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/en-us/docs/08_rpc_call.html" target="_self">RPC Tutorial</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/en-us/docs/09_ws_call.html" target="_self">Websocket Tutorial</a></li></ul></li><li class="menu-item menu-item-level-1"><span>Fast Learning</span><ul><li style="height:144px;overflow:hidden" class="menu-item menu-item-level-2"><span>DAPP Guild<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo1.html" target="_self">Installation And Operation</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">Configuration Node</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">Command Line Tool</a></li></ul></li><li style="height:144px;overflow:hidden" class="menu-item menu-item-level-2"><span>Development Data Collection<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo1.html" target="_self">Document</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">Configuration Node</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">Command Line Tool</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>Docking Guild</span><ul><li style="height:108px;overflow:hidden" class="menu-item menu-item-level-2"><span>Exchange Docking Guide<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo1.html" target="_self">Installation And Operation</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">Configuration Node</a></li></ul></li><li style="height:144px;overflow:hidden" class="menu-item menu-item-level-2"><span>Wallet Docking Guide<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo1.html" target="_self">Sign Key</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">Configuration Node</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">Begining</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>SDK Total</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/en-us/docs/10_other_sdk.html" target="_self">Third party SDK</a></li></ul></li><li class="menu-item menu-item-level-1"><span>Ecosphere</span><ul><li style="height:180px;overflow:hidden" class="menu-item menu-item-level-2"><span>Bytom Ecology<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/en-us/docs/23_wallet.html" target="_self">Full Node Wallet</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/24_ligth_wallet.html" target="_self">Light Wallet</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/25_block_explorer.html" target="_self">Blockchain Browser</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/26_mining_pool.html" target="_self">Mine Pool</a></li></ul></li><li style="height:144px;overflow:hidden" class="menu-item menu-item-level-2"><span>Floor Application<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo1.html" target="_self">Payment Case</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">Data OnChain</a></li><li class="menu-item menu-item-level-3"><a href="/en-us/docs/demo2.html" target="_self">Dapp</a></li></ul></li></ul></li></ul></div><div class="doc-content markdown-body"><h1>nodes</h1>
<p>A Bytom P2P network has different kinds of nodes with different requirements for connectivity to one another.
This document describes what kind of nodes should enable and how they should work.</p>
<h2>Seeds</h2>
<p>Seeds are the first point of contact for a new node.
The new node discovers other nodes in the network through seeds.</p>
<h2>New Full Node</h2>
<p>The full node saves the complete data on the chain.
A new node needs a few things to connect to the network:</p>
<ul>
<li>a list of seeds, which can be provided to Bytom via config file or command flags.</li>
<li>a <code>ChainID</code>, also called <code>Network</code> at the p2p layer.</li>
<li>a recent block height, H, and hash, HASH for the blockchain.</li>
</ul>
<p>With the above, the node then queries some peers from the discovery service, dials those peers, and runs the net<br>
sync protocols with those it successfully connects to.</p>
<h2>Vault Mode Node</h2>
<p>Node runs in an offline environment. Can be used to sign a transaction, but can't broadcast a transaction.</p>
<h1>Node Discovery Protocol</h1>
<p>This specification defines the Node Discovery protocol, a Kademlia-like DHT that
stores information about Bytom nodes. The Kademlia structure was chosen because it yields a topology of low diameter.</p>
<h2>Node Identities</h2>
<p>Every node has a cryptographic identity, a key on the Ed25519. The public
key of the node serves as its identifier or 'node ID'.</p>
<p>The 'distance' between two node IDs is the bitwise exclusive or on the hashes of the
public keys, taken as the number.</p>
<pre><code class="language-text">distance(n₁, n₂) = keccak256(n₁) XOR keccak256(n₂)
</code></pre>
<h2>Node Table</h2>
<p>Nodes in the Discovery Protocol keep information about other nodes in their neighborhood.
Neighbor nodes are stored in a routing table consisting of 'k-buckets'. For each <code>0 ≤ i &lt; 256</code>, every node keeps a k-bucket for nodes of distance between <code>2i</code> and <code>2i+1</code> from
itself.</p>
<p>The Node Discovery Protocol uses <code>k = 16</code>, i.e. every k-bucket contains up to 16 node
entries. The entries are sorted by time last seen — least-recently seen node at the head,
most-recently seen at the tail.</p>
<p>Whenever a new node N₁ is encountered, it can be inserted into the corresponding bucket.
If the bucket contains less than <code>k</code> entries N₁ can simply be added as the first entry. If
the bucket already contains <code>k</code> entries, the least recently seen node in the bucket, N₂,
needs to be revalidated by sending a ping packet. If no reply is received from N₂ it is
considered dead, removed and N₁ added to the front of the bucket.</p>
<h2>Recursive Lookup</h2>
<p>A 'lookup' locates the <code>k</code> closest nodes to a node ID.</p>
<p>The lookup initiator starts by picking <code>α</code> closest nodes to the target it knows of. The
initiator then sends concurrent FindNode packets to those nodes. <code>α</code> is a system-wide
concurrency parameter, such as 3. In the recursive step, the initiator resends FindNode to
nodes it has learned about from previous queries. Of the <code>k</code> nodes the initiator has heard
of closest to the target, it picks <code>α</code> that it has not yet queried and resends FindNode to
them. Nodes that fail to respond quickly are removed from consideration until and unless
they do respond.</p>
<p>If a round of FindNode queries fails to return a node any closer than the closest already
seen, the initiator resends the find node to all of the <code>k</code> closest nodes it has not
already queried. The lookup terminates when the initiator has queried and gotten responses
from the <code>k</code> closest nodes it has seen.</p>
<h2>Wire Protocol</h2>
<p>Node discovery messages are sent as UDP datagrams. The maximum size of any packet is 1280
bytes.</p>
<pre><code class="language-text">packet = packet-header || packet-data
</code></pre>
<p>Every packet starts with a header:</p>
<pre><code class="language-text">packet-header = hash || signature || packet-type
hash = keccak256(signature || packet-type || packet-data)
signature = sign(packet-type || packet-data)
</code></pre>
<p>The <code>hash</code> exists to make the packet format recognizable when running multiple protocols
on the same UDP port. It serves no other purpose.</p>
<p>Every packet is signed by the node's identity key. The <code>signature</code> is encoded as a byte
array of length 65 as the concatenation of the signature values <code>r</code>, <code>s</code> and the 'recovery
id' <code>v</code>.</p>
<p>The <code>packet-type</code> is a single byte defining the type of message. Valid packet types are
listed below. Data after the header is specific to the packet type and is encoded as an
RLP list. As per EIP-8, implementations should ignore any additional elements in the list
as well as any extra data after the list.</p>
<h3>Ping Packet (0x01)</h3>
<pre><code class="language-text">packet-data = [version, from, to, expiration]
version = 4
from = [sender-ip, sender-udp-port, sender-tcp-port]
to = [recipient-ip, recipient-udp-port, 0]
</code></pre>
<p>The <code>expiration</code> field is an absolute UNIX time stamp. Packets containing a time stamp
that lies in the past are expired may not be processed.</p>
<p>When a ping packet is received, the recipient should reply with a pong packet. It may also
consider the sender for addition into the node table.</p>
<h3>Pong Packet (0x02)</h3>
<pre><code class="language-text">packet-data = [to, ping-hash, expiration]
</code></pre>
<p>Pong is the reply to ping.</p>
<p><code>ping-hash</code> should be equal to <code>hash</code> of the corresponding ping packet. Implementations
should ignore unsolicited pong packets that do not contain the hash of the most recent
ping packet.</p>
<h3>FindNode Packet (0x03)</h3>
<pre><code class="language-text">packet-data = [target, expiration]
</code></pre>
<p>A FindNode packet requests information about nodes close to <code>target</code>. The <code>target</code> is a
Ed25519 public key. When FindNode is received, the recipient should reply with
neighbors packets containing the closest 16 nodes to target found in its local table.</p>
<h3>Neighbors Packet (0x04)</h3>
<pre><code class="language-text">packet-data = [nodes, expiration]
nodes = [[ip, udp-port, tcp-port, node-id], ... ]
</code></pre>
<p>Neighbors is the reply to FindNode.</p>
<h1>P2P Multiplex Connection</h1>
<h2>MConnection</h2>
<p><code>MConnection</code> is a multiplex connection that supports multiple independent streams
with distinct quality of service guarantees atop a single TCP connection.
Each stream is known as a <code>Channel</code> and each <code>Channel</code> has a globally unique <em>byte id</em>.
Each <code>Channel</code> also has a relative priority that determines the quality of service
of the <code>Channel</code> compared to other <code>Channel</code>s.
The <em>byte id</em> and the relative priorities of each <code>Channel</code> are configured upon
initialization of the connection.</p>
<p>The <code>MConnection</code> supports three packet types:</p>
<ul>
<li>Ping</li>
<li>Pong</li>
<li>Msg</li>
</ul>
<h3>Ping and Pong</h3>
<p>The ping and pong messages consist of writing a single byte to the connection; 0x1 and 0x2, respectively.</p>
<p>When we haven't received any messages on an <code>MConnection</code> in time <code>pingTimeout</code>, we send a ping message.
When a ping is received on the <code>MConnection</code>, a pong is sent in response.</p>
<p>If a pong or message is not received in sufficient time after a ping, the peer is disconnected from.</p>
<h3>Msg</h3>
<p>Messages in channels are chopped into smaller <code>msgPacket</code>s for multiplexing.</p>
<pre><code>type msgPacket struct {
	ChannelID byte
	EOF       byte // 1 means message ends here.
	Bytes     []byte
}
</code></pre>
<p>The <code>msgPacket</code> is serialized using <a href="https://github.com/Bytom/bytom/tree/master/vendor/github.com/tendermint/go-wire">go-wire</a> and prefixed with 0x3.
The received <code>Bytes</code> of a sequential set of packets are appended together
until a packet with <code>EOF=1</code> is received, then the complete serialized message
is returned for processing by the <code>onReceive</code> function of the corresponding channel.</p>
<h3>Multiplexing</h3>
<p>Messages are sent from a single <code>sendRoutine</code>, which loops over a select statement and results in the sending
of a ping, a pong, or a batch of data messages. The batch of data messages may include messages from multiple channels.
Message bytes are queued for sending in their respective channel, with each channel holding one unsent message at a time.
Messages are chosen for a batch one at a time from the channel with the lowest ratio of recently sent bytes to channel priority.</p>
<h2>Sending Messages</h2>
<p>There are two methods for sending messages:</p>
<pre><code class="language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MConnection)</span> <span class="hljs-title">Send</span><span class="hljs-params">(chID <span class="hljs-keyword">byte</span>, msg <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">bool</span></span> {}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MConnection)</span> <span class="hljs-title">TrySend</span><span class="hljs-params">(chID <span class="hljs-keyword">byte</span>, msg <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">bool</span></span> {}
</code></pre>
<p><code>Send(chID, msg)</code> is a blocking call that waits until <code>msg</code> is successfully queued
for the channel with the given id byte <code>chID</code>.  The message <code>msg</code> is serialized
using the <code>tendermint/wire</code> submodule's <code>WriteBinary()</code> reflection routine.</p>
<p><code>TrySend(chID, msg)</code> is a nonblocking call that queues the message msg in the channel
with the given id byte chID if the queue is not full; otherwise it returns false immediately.</p>
<p><code>Send()</code> and <code>TrySend()</code> are also exposed for each <code>Peer</code>.</p>
<h2>Peer</h2>
<p>Each peer has one <code>MConnection</code> instance, and includes other information such as whether the connection
was outbound, whether the connection should be recreated if it closes, various identity information about the node,
and other higher level thread-safe data used by the reactors.</p>
<h2>Switch/Reactor</h2>
<p>The <code>Switch</code> handles peer connections and exposes an API to receive incoming messages
on <code>Reactors</code>.  Each <code>Reactor</code> is responsible for handling incoming messages of one
or more <code>Channels</code>.  So while sending outgoing messages is typically performed on the peer,
incoming messages are received on the reactor.</p>
<pre><code class="language-go"><span class="hljs-comment">// Declare a MyReactor reactor that handles messages on MyChannelID.</span>
<span class="hljs-keyword">type</span> MyReactor <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(reactor MyReactor)</span> <span class="hljs-title">GetChannels</span><span class="hljs-params">()</span> []*<span class="hljs-title">ChannelDescriptor</span></span> {
    <span class="hljs-keyword">return</span> []*ChannelDescriptor{ChannelDescriptor{ID:MyChannelID, Priority: <span class="hljs-number">1</span>}}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(reactor MyReactor)</span> <span class="hljs-title">Receive</span><span class="hljs-params">(chID <span class="hljs-keyword">byte</span>, peer *Peer, msgBytes []<span class="hljs-keyword">byte</span>)</span></span> {
    r, n, err := bytes.NewBuffer(msgBytes), <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int64</span>), <span class="hljs-built_in">new</span>(error)
    msgString := ReadString(r, n, err)
    fmt.Println(msgString)
}

<span class="hljs-comment">// Other Reactor methods omitted for brevity</span>
...

<span class="hljs-keyword">switch</span> := NewSwitch([]Reactor{MyReactor{}})

...

<span class="hljs-comment">// Send a random message to all outbound connections</span>
<span class="hljs-keyword">for</span> _, peer := <span class="hljs-keyword">range</span> <span class="hljs-keyword">switch</span>.Peers().List() {
    <span class="hljs-keyword">if</span> peer.IsOutbound() {
        peer.Send(MyChannelID, <span class="hljs-string">"Here's a random message"</span>)
    }
}
</code></pre>
<h1>Peers</h1>
<p>This document explains how Bytom Peers are identified and how they connect to one another.</p>
<h2>Peer Identity</h2>
<p>Bytom peers are expected to maintain long-term persistent identities in the form of a public key.
Each peer has an ID defined as <code>peer.PubKey == privKey.PubKey().Unwrap().(crypto.PubKeyEd25519)</code>.</p>
<p>When attempting to connect to a peer, we use the PeerURL: <code>&lt;ID&gt;@&lt;IP&gt;:&lt;PORT&gt;</code>.
We will attempt to connect to the peer at IP:PORT, and verify,
via authenticated encryption, that it is in possession of the private key
corresponding to <code>&lt;ID&gt;</code>. This prevents man-in-the-middle attacks on the peer layer.</p>
<h2>Connections</h2>
<p>All p2p connections use TCP.
Upon establishing a successful TCP connection with a peer,
two handhsakes are performed: one for authenticated encryption, and one for versioning.
Both handshakes have configurable timeouts (they should complete quickly).</p>
<h3>Authenticated Encryption Handshake</h3>
<p>System implements the Station-to-Station protocol
using ED25519 keys for Diffie-Helman key-exchange and NACL SecretBox for encryption.
It goes as follows:</p>
<ul>
<li>generate an emphemeral ED25519 keypair</li>
<li>send the ephemeral public key to the peer</li>
<li>wait to receive the peer's ephemeral public key</li>
<li>compute the Diffie-Hellman shared secret using the peers ephemeral public key and our ephemeral private key</li>
<li>generate two nonces to use for encryption (sending and receiving) as follows:
<ul>
<li>sort the ephemeral public keys in ascending order and concatenate them</li>
<li>RIPEMD160 the result</li>
<li>append 4 empty bytes (extending the hash to 24-bytes)</li>
<li>the result is nonce1</li>
<li>flip the last bit of nonce1 to get nonce2</li>
<li>if we had the smaller ephemeral pubkey, use nonce1 for receiving, nonce2 for sending;
else the opposite</li>
</ul>
</li>
<li>all communications from now on are encrypted using the shared secret and the nonces, where each nonce
increments by 2 every time it is used</li>
<li>we now have an encrypted channel, but still need to authenticate</li>
<li>generate a common challenge to sign:
<ul>
<li>SHA256 of the sorted (lowest first) and concatenated ephemeral pub keys</li>
</ul>
</li>
<li>sign the common challenge with our persistent private key</li>
<li>send the go-wire encoded persistent pubkey and signature to the peer</li>
<li>wait to receive the persistent public key and signature from the peer</li>
<li>verify the signature on the challenge using the peer's persistent public key</li>
</ul>
<p>If this is an outgoing connection (we dialed the peer) and we used a peer ID,
then finally verify that the peer's persistent public key corresponds to the peer ID we dialed,
ie. <code>peer.PubKey.Address() == &lt;ID&gt;</code>.</p>
<p>The connection has now been authenticated. All traffic is encrypted.</p>
<p>Note: only the dialer can authenticate the identity of the peer,
but this is what we care about since when we join the network we wish to
ensure we have reached the intended peer (and are not being MITMd).</p>
<h3>Peer Filter</h3>
<p>Before continuing, we check if the new peer has the same ID as ourselves or
an existing peer. If so, we disconnect.</p>
<p>We also check the peer's address and public key against
an blacklist - If the node is in the blacklist, the connection is prohibited for 24 hours.</p>
<h3>Version Handshake</h3>
<p>The Tendermint Version Handshake allows the peers to exchange their NodeInfo:</p>
<pre><code class="language-golang"><span class="hljs-keyword">type</span> NodeInfo <span class="hljs-keyword">struct</span> {
  PubKey     crypto.PubKeyEd25519
  ListenAddr <span class="hljs-keyword">string</span>
  Network    <span class="hljs-keyword">string</span>
  Version    <span class="hljs-keyword">string</span>
  Moniker    <span class="hljs-keyword">string</span>
  Other      []<span class="hljs-keyword">string</span>
}
</code></pre>
<p>The connection is disconnected if:</p>
<ul>
<li><code>peer.NodeInfo.Version</code> is not formatted as <code>X.X.X</code> where X are integers known as Major, Minor, and Revision</li>
<li><code>peer.NodeInfo.Version</code> Major is not the same as ours</li>
<li><code>peer.NodeInfo.Network</code> is not the same as ours</li>
</ul>
<p>At this point, if we have not disconnected, the peer is valid.
It is added to the switch and hence all reactors via the <code>AddPeer</code> method.
Note that each reactor may handle multiple channels.</p>
<h2>Connection Activity</h2>
<p>Once a peer is added, incoming messages for a given reactor are handled through
that reactor's <code>Receive</code> method, and output messages are sent directly by the Reactors
on each peer. A typical reactor maintains per-peer go-routine(s) that handle this.</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><div class="cols-container"><div class="col col-12"><h3>Disclaimer</h3><p>the disclaimer content</p></div><div class="col col-6"><dl><dt>Documentation</dt><dd><a href="/en-us/docs/demo1.html" target="_self">Overview</a></dd><dd><a href="/en-us/docs/demo2.html" target="_self">Quick start</a></dd><dd><a href="/en-us/docs/dir/demo3.html" target="_self">Developer guide</a></dd></dl></div><div class="col col-6"><dl><dt>Resources</dt><dd><a href="/en-us/blog/index.html" target="_self">Blog</a></dd><dd><a href="/en-us/community/index.html" target="_self">Community</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018 Bytomxxxxxxxx</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>