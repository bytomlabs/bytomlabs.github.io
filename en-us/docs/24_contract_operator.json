{
  "filename": "24_contract_operator.md",
  "__html": "<h1>Logical and numeric operators</h1>\n<table>\n<thead>\n<tr>\n<th>NAME</th>\n<th>CODE</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_1ADD</td>\n<td>0x8b</td>\n<td>Pops a number from the data stack, adds 1 to it, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_1SUB</td>\n<td>0x8c</td>\n<td>Pops a number from the data stack, subtracts 1 from it, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_2MUL</td>\n<td>0x8d</td>\n<td>Pops a number from the data stack, multiplies 2 to it, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_2DIV</td>\n<td>0x8e</td>\n<td>Pops a number from the data stack, divides 2 from it, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_NEGATE</td>\n<td>0x8f</td>\n<td>Pops a number from the data stack, negates it, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_ABS</td>\n<td>0x90</td>\n<td>Pops a number from the data stack, negates it if it is less than 0, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_NOT</td>\n<td>0x91</td>\n<td>Pops a boolean from the data stack, negates it, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_0NOTEQUAL</td>\n<td>0x92</td>\n<td>Pops a number from the data stack, and results in false if the number is equal to 0 and true otherwise. Pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_ADD</td>\n<td>0x93</td>\n<td>Pops two numbers from the data stack, adds them, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_SUB</td>\n<td>0x94</td>\n<td>Pops two numbers from the data stack, takes their difference, and pushes the result to the data stack. (eg.x-y)</td>\n</tr>\n<tr>\n<td>OP_MUL</td>\n<td>0x95</td>\n<td>Pops two numbers from the data stack, multiplies them, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_DIV</td>\n<td>0x96</td>\n<td>Pops two numbers from the data stack, divides them rounding toward zero to an integer, and pushes the result to the data stack.(eg.x/y)</td>\n</tr>\n<tr>\n<td>OP_MOD</td>\n<td>0x97</td>\n<td>Pops two numbers from their data stack, determines the remainder of x divided by y, and pushes the result to the data stack. A non-zero result has the same sign as the divisor.(eg.x%y)</td>\n</tr>\n<tr>\n<td>OP_LSHIFT</td>\n<td>0x98</td>\n<td>Pops two numbers from the data stack, multiplies x by 2**y (i.e., an arithmetic left shift with sign extension), coerces the result to a string, and pushes it to the data stack. (eg.x &lt;&lt; y)</td>\n</tr>\n<tr>\n<td>OP_RSHIFT</td>\n<td>0x99</td>\n<td>Pops two numbers from the data stack, divides x by 2**y rounding to an integer toward negative infinity (i.e., an arithmetic right shift with sign extension), and pushes the result to the stack. (eg.x &gt;&gt; y)</td>\n</tr>\n<tr>\n<td>OP_BOOLAND</td>\n<td>0x9a</td>\n<td>Pops two booleans from the data stack. Pushes true to the data stack if both are true, and pushes false otherwise.</td>\n</tr>\n<tr>\n<td>OP_BOOLOR</td>\n<td>0x9b</td>\n<td>Pops two booleans from the data stack. Pushes false to the data stack if both are false and pushes true otherwise.</td>\n</tr>\n<tr>\n<td>OP_NUMEQUAL</td>\n<td>0x9c</td>\n<td>Pops two numbers from the data stack. Pushes true to the data stack if they are equal and pushes false otherwise.</td>\n</tr>\n<tr>\n<td>OP_NUMEQUALVERIFY</td>\n<td>0x9d</td>\n<td>Equivalent to <code>NUMEQUAL VERIFY</code>. Pops two numbers from the data stack, and fails if they are not equal.</td>\n</tr>\n<tr>\n<td>OP_NUMNOTEQUAL</td>\n<td>0x9e</td>\n<td>Pops two numbers from the data stack, results in false if they are equal and in true otherwise, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_LESSTHAN</td>\n<td>0x9f</td>\n<td>Pops two numbers from the data stack, results in true if x is less than y and false otherwise, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_GREATERTHAN</td>\n<td>0xa0</td>\n<td>Pops two numbers from the data stack, results in true if x is greater than y and in false otherwise, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_LESSTHANOREQUAL</td>\n<td>0xa1</td>\n<td>Pops two numbers from the data stack, results in true if x is less than or equal to y and in false otherwise, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_GREATERTHANOREQUAL</td>\n<td>0xa2</td>\n<td>Pops two numbers from the data stack, results in true if x is greater than or equal to y and in false otherwise, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_MIN</td>\n<td>0xa3</td>\n<td>Pops two numbers from the data stack, results in x if x is less than or equal to y and in y otherwise, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_MAX</td>\n<td>0xa4</td>\n<td>Pops two numbers from the stack, results in x if x is greater than or equal to y and in y otherwise, and pushes the result to the data stack.</td>\n</tr>\n<tr>\n<td>OP_WITHIN</td>\n<td>0xa5</td>\n<td>Pops two numbers from the stack, results in true if x is greater or equal to the mininum value y and less than the maximum value z, and pushes the result to the stack.</td>\n</tr>\n</tbody>\n</table>\n<h1>Bitwise Operator</h1>\n<table>\n<thead>\n<tr>\n<th>NAME</th>\n<th>CODE</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_INVERT</td>\n<td>0x83</td>\n<td>Inverts bits in the first item on the data stack.</td>\n</tr>\n<tr>\n<td>OP_AND</td>\n<td>0x84</td>\n<td>Bitwise AND operation. Longer item is truncated, keeping the prefix.</td>\n</tr>\n<tr>\n<td>OP_OR</td>\n<td>0x85</td>\n<td>Bitwise OR operation. Shorter item is zero-padded to the right.</td>\n</tr>\n<tr>\n<td>OP_XOR</td>\n<td>0x86</td>\n<td>Bitwise XOR operation. Shorter item is zero-padded to the right.</td>\n</tr>\n<tr>\n<td>OP_EQUAL</td>\n<td>0x87</td>\n<td>Pops two strings from the stack and compares them byte-by-byte. Pushes true if the strings are equal, false otherwise.</td>\n</tr>\n<tr>\n<td>OP_EQUALVERIFY</td>\n<td>0x88</td>\n<td>Same as <code>EQUAL VERIFY</code>. Pops two strings from the stack, compares them byte-by-byte, and fails execution if they are not equal.</td>\n</tr>\n</tbody>\n</table>\n<h1>Splice operators</h1>\n<table>\n<thead>\n<tr>\n<th>NAME</th>\n<th>CODE</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_CAT</td>\n<td>0x7e</td>\n<td>Concatenates top two items on the data stack.</td>\n</tr>\n<tr>\n<td>OP_SUBSTR</td>\n<td>0x7f</td>\n<td>Extracts a substring of <code>string</code> of a given size <code>n</code> at a given offset <code>m</code>.</td>\n</tr>\n<tr>\n<td>OP_LEFT</td>\n<td>0x80</td>\n<td>Extracts a prefix of <code>string</code> with the given size <code>n</code>.</td>\n</tr>\n<tr>\n<td>OP_RIGHT</td>\n<td>0x81</td>\n<td>Extracts a suffix of <code>string</code> with the given size <code>n</code>.</td>\n</tr>\n<tr>\n<td>OP_SIZE</td>\n<td>0x82</td>\n<td>Pushes the size of <code>string</code> encoded as a number <code>n</code> without removing <code>string</code> from the data stack.</td>\n</tr>\n<tr>\n<td>OP_CATPUSHDATA</td>\n<td>0x89</td>\n<td>Appends second <code>string</code> encoded as the most compact <code>PUSHDATA</code> instruction. This is used for building new programs piecewise.</td>\n</tr>\n</tbody>\n</table>\n<h1>Cryptographic instructions</h1>\n<table>\n<thead>\n<tr>\n<th>NAME</th>\n<th>CODE</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_SHA256</td>\n<td>0xa8</td>\n<td>Replaces top stack item with its SHA-256 hash value.</td>\n</tr>\n<tr>\n<td>OP_SHA3</td>\n<td>0xaa</td>\n<td>Replaces top stack item with its SHA3-256 hash value.</td>\n</tr>\n<tr>\n<td>OP_HASH160</td>\n<td>0xab</td>\n<td>Replaces top stack item with its Ripemd160 hash value.</td>\n</tr>\n<tr>\n<td>OP_CHECKSIG</td>\n<td>0xac</td>\n<td>Pops the top three items on the data stack, verifies the signature sig of the hash with a given public key pubkey and pushes true if the signature is valid; pushes false if it is not. Fails if hash is not a 32-byte string.</td>\n</tr>\n<tr>\n<td>OP_CHECKMULTISIG</td>\n<td>0xad</td>\n<td>Pops non-negative numbers n and m from the data stack(n and m is positive), Pops n public keys, Pops hash from the data stack, Pops m signatures, Verifies signatures one by one against the public keys and the given hash. Signatures must be in the same order as public keys and no two signatures are verified with the same public key, Pushes true if all of the signatures are valid, and false otherwise.</td>\n</tr>\n<tr>\n<td>OP_TXSIGHASH</td>\n<td>0xae</td>\n<td>Computes the transaction signature hash corresponding to the current entry. Equals SHA3-256 of the concatenation of the current entry ID and transaction ID: <code>TXSIGHASH = SHA3-256(entryID || txID)</code></td>\n</tr>\n</tbody>\n</table>\n<h1>Control Flow Operators</h1>\n<table>\n<thead>\n<tr>\n<th>NAME</th>\n<th>CODE</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_JUMP</td>\n<td>0x63</td>\n<td>Followed by a 4-byte unsigned integer address, sets the PC to address. Fails if not followed by 4 bytes. Note: this opcode may cause some instructions to not be executed.</td>\n</tr>\n<tr>\n<td>OP_JUMPIF</td>\n<td>0x64</td>\n<td>Followed by a 4-byte unsigned integer address, pops a boolean from the data stack. If it is true, sets the PC to address. If it is false, does nothing. Fails if not followed by 4 bytes. Note: this opcode may cause some instructions to not be executed.</td>\n</tr>\n<tr>\n<td>OP_VERIFY</td>\n<td>0x69</td>\n<td>Fails execution if the top item on the data stack is false. Otherwise, removes the top item.</td>\n</tr>\n<tr>\n<td>OP_FAIL</td>\n<td>0x6a</td>\n<td>Fails execution unconditionally.</td>\n</tr>\n<tr>\n<td>OP_CHECKPREDICATE</td>\n<td>0xc0</td>\n<td>Pops 3 items from the data stack: limit, predicate and n. If limit equals zero, sets it to the VM’s remaining run limit minus 256. Reduces VM’s run limit by 256 + limit. Instantiates a new VM instance (“child VM”) with its run limit set to limit. Moves the top n items from the parent VM’s data stack to the child VM’s data stack without incurring run limit refund or charge of their standard memory cost in either VM. The order of the moved items is unchanged. The memory cost of these items will be refunded when the child VM pops them, or when the child VM is destroyed and its parent VM is refunded. Child VM evaluates the predicate and pushes true to the parent VM data stack if the evaluation did not fail and the child VM’s data stack is non-empty with a true value on top (this implements the same semantics as for the top-level verify predicate operation). It pushes false otherwise. Note that the parent VM does not fail when the child VM exhausts its run limit or otherwise fails.</td>\n</tr>\n</tbody>\n</table>\n<h1>Stack control operators</h1>\n<table>\n<thead>\n<tr>\n<th>NAME</th>\n<th>CODE</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_TOALTSTACK</td>\n<td>0x6b</td>\n<td>Moves the top item from the data stack to the alt stack.</td>\n</tr>\n<tr>\n<td>OP_FROMALTSTACK</td>\n<td>0x6c</td>\n<td>Moves the top item from the alt stack to the data stack. Fails if the alt stack is empty.</td>\n</tr>\n<tr>\n<td>OP_2DROP</td>\n<td>0x6d</td>\n<td>Removes top 2 items from the data stack.</td>\n</tr>\n<tr>\n<td>OP_2DUP</td>\n<td>0x6e</td>\n<td>Duplicates top 2 items on the data stack.</td>\n</tr>\n<tr>\n<td>OP_3DUP</td>\n<td>0x6f</td>\n<td>Duplicates top 3 items on the data stack.</td>\n</tr>\n<tr>\n<td>OP_2OVER</td>\n<td>0x70</td>\n<td>Duplicates two items below the top two items on the data stack.</td>\n</tr>\n<tr>\n<td>OP_2ROT</td>\n<td>0x71</td>\n<td>Moves 2 items below the top 4 items on the data stack to the top of the stack.</td>\n</tr>\n<tr>\n<td>OP_2SWAP</td>\n<td>0x72</td>\n<td>Moves 2 items below the top 2 items on the data stack to the top of the stack.</td>\n</tr>\n<tr>\n<td>OP_IFDUP</td>\n<td>0x73</td>\n<td>Duplicates the top item only if it’s not false.</td>\n</tr>\n<tr>\n<td>OP_DEPTH</td>\n<td>0x74</td>\n<td>Adds the size of the data stack encoded as a VM number.</td>\n</tr>\n<tr>\n<td>OP_DROP</td>\n<td>0x75</td>\n<td>Removes the top item from the data stack.</td>\n</tr>\n<tr>\n<td>OP_DUP</td>\n<td>0x76</td>\n<td>Duplicates the top item on the data stack.</td>\n</tr>\n<tr>\n<td>OP_NIP</td>\n<td>0x77</td>\n<td>Removes the item below the top one on the data stack.</td>\n</tr>\n<tr>\n<td>OP_OVER</td>\n<td>0x78</td>\n<td>Copies the second from the top item to the top of the data stack.</td>\n</tr>\n<tr>\n<td>OP_PICK</td>\n<td>0x79</td>\n<td>Copies n+2th item from the top to the top of the data stack. Fails if the top item is not a valid non-negative number or there are fewer than n+2 items on the stack.</td>\n</tr>\n<tr>\n<td>OP_ROLL</td>\n<td>0x7a</td>\n<td>Moves n+2th item from the top to the top of the data stack. Fails if the top item is not a valid non-negative number or there are fewer than n+2 items on the stack.</td>\n</tr>\n<tr>\n<td>OP_ROT</td>\n<td>0x7b</td>\n<td>Moves the third item from the top to the top of the data stack.</td>\n</tr>\n<tr>\n<td>OP_SWAP</td>\n<td>0x7c</td>\n<td>Swaps top two items on the data stack.</td>\n</tr>\n<tr>\n<td>OP_TUCK</td>\n<td>0x7d</td>\n<td>Tucks the second item from the top of the data stack with two copies of the top item.</td>\n</tr>\n</tbody>\n</table>\n<h1>Introspection instructions</h1>\n<p>The following instructions are defined within a transaction context. In the block context these instructions cause VM to halt immediately and return false.</p>\n<p>Note: standard memory cost is applied after the instruction is executed in order to determine the exact size of the encoded data (this also applies to ASSET, even though the result is always 32 bytes long).</p>\n<table>\n<thead>\n<tr>\n<th>NAME</th>\n<th>CODE</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_CHECKOUTPUT</td>\n<td>0xc1</td>\n<td>Pops 6 items from the data stack: index, amount, assetid, version, prog. check the specified destination entry.</td>\n</tr>\n<tr>\n<td>OP_ASSET</td>\n<td>0xc2</td>\n<td>If the current entry is an Issuance1, pushes Value.AssetID. If the current entry is a Spend1, pushes the SpentOutput.Source.Value.AssetID of that entry. Fails if executed in the block context. Fails if the entry is not an Issuance1 or a Spend1.</td>\n</tr>\n<tr>\n<td>OP_AMOUNT</td>\n<td>0xc3</td>\n<td>If the current entry is an Issuance1, pushes Value.Amount. If the current entry is a Spend1, pushes the SpentOutput.Source.Value.Amount of that entry. Fails if executed in the block context. Fails if the entry is not an Issuance1 or a Spend1.</td>\n</tr>\n<tr>\n<td>OP_PROGRAM</td>\n<td>0xc4</td>\n<td>Pushes a program based on a type of current entry and the context.  Fails if executed in the block context.</td>\n</tr>\n<tr>\n<td>OP_INDEX</td>\n<td>0xc9</td>\n<td>Pushes the ValueDestination.position of the current entry on the data stack. Fails if the current entry is not an issuance or a spend.</td>\n</tr>\n<tr>\n<td>OP_ENTRYID</td>\n<td>0xca</td>\n<td>Pushes the current entry ID on the data stack (e.g. a spend or an issuance). Fails if executed in the block context.</td>\n</tr>\n<tr>\n<td>OP_OUTPUTID</td>\n<td>0xcb</td>\n<td>Pushes the spent output ID on the data stack. Fails if executed in the block context. Fails if the current entry is not a spend.</td>\n</tr>\n<tr>\n<td>OP_BLOCKHEIGHT</td>\n<td>0xcd</td>\n<td>Pushes the current block height on the data stack. Fails if executed in the transaction context.</td>\n</tr>\n</tbody>\n</table>\n<h1>Instructions pushing data on stack</h1>\n<table>\n<thead>\n<tr>\n<th>NAME</th>\n<th>CODE</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_PUSHDATA1</td>\n<td>0x4c</td>\n<td>It is followed by a 1-byte length prefix encoding a length n, then n bytes of data to push (supports up to 255 bytes).</td>\n</tr>\n<tr>\n<td>OP_PUSHDATA2</td>\n<td>0x4d</td>\n<td>It is followed by a 2-byte little-endian length prefix encoding a length n, then n bytes of data to push (supports up to 65535 bytes).</td>\n</tr>\n<tr>\n<td>OP_PUSHDATA4</td>\n<td>0x4e</td>\n<td>It is followed by a 4-byte little-endian length prefix encoding a length n, then n bytes of data to push (supports up to 4294967295 bytes).</td>\n</tr>\n<tr>\n<td>OP_1NEGATE</td>\n<td>0x4f</td>\n<td>Pushes &quot;ff ff ff ff ff ff ff ff&quot; (the VM number -1) onto the data stack.</td>\n</tr>\n<tr>\n<td>OP_NOP</td>\n<td>0x61</td>\n<td>No operation.</td>\n</tr>\n<tr>\n<td>OP_FALSE / OP_0</td>\n<td>0x00</td>\n<td>Equivalent to OP_0, Pushes an empty string (the VM number 0) to the data stack.</td>\n</tr>\n<tr>\n<td>OP_TRUE</td>\n<td>0x51</td>\n<td>Equivalent to OP_1, Pushes an empty string (the VM number 1) to the data stack.</td>\n</tr>\n<tr>\n<td>OP_1 ~ OP_16</td>\n<td>0x51 ~  0x60</td>\n<td>Pushes number <code>n</code> on the data stack. the range of <code>n</code> is [1, 16].</td>\n</tr>\n<tr>\n<td>OP_DATA_1 ~ OP_DATA_75</td>\n<td>0x01 ~  0x4b</td>\n<td>It is followed by <code>n</code> bytes of data to be pushed onto the data stack as a single VM string. the range of <code>n</code> is [1, 75].</td>\n</tr>\n</tbody>\n</table>\n",
  "link": "/en-us/docs/24_contract_operator.html",
  "meta": {}
}