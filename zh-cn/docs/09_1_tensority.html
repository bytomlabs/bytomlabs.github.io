<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="09_1_tensority" />
	<meta name="description" content="09_1_tensority" />
	<!-- 网页标签标题 -->
	<title>Tensority算法</title>
	<link rel="shortcut icon" href="/img/docsite.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><span class="language-switch language-switch-normal">En</span><span class="github"><a title="Github" target="_blank" href="https://github.com/Bytom/bytom"><img src="/img/github.png" alt=""/></a></span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/dev" target="_self">开发者</a></li></ul></div></div></header><div style="background:url(/img/banner.png)  top center no-repeat" class="bar"><div class="bar-body"><p>比原链开发文档</p></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span></span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/01_bytom.html" target="_self">比原链</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/02_release.html" target="_self">版本计划</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/03_technology.html" target="_self">技术介绍</a></li><li style="height:216px;overflow:hidden" class="menu-item menu-item-level-2"><span>客户端<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/04_1_bytom.html" target="_self">Bytomd</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/04_2_simd.html" target="_self">Simd</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/04_3_spv.html" target="_self">SPV</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/04_4_vapor.html" target="_self">Vapor</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/04_5_gm.html" target="_self">GM</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/05_compile.html" target="_self">编译钱包</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/06_network.html" target="_self">网络</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/07_dashboard.html" target="_self">仪表盘</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/08_cli_guide.html" target="_self">钱包命令</a></li><li style="height:216px;overflow:hidden" class="menu-item menu-item-level-2"><span>挖矿<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/09_1_tensority.html" target="_self">Tensority算法</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/09_2_cpu.html" target="_self">CPU挖矿</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/09_3_gpu.html" target="_self">GPU挖矿</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/09_4_asic.html" target="_self">ASIC矿机</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/09_5_mining_pools.html" target="_self">矿池挖矿</a></li></ul></li><li style="height:180px;overflow:hidden" class="menu-item menu-item-level-2"><span>工具<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/10_1_blockmeta.html" target="_self">Blockmeta</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/10_2_bytom_kit.html" target="_self">Bytom Kit</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/10_3_byone.html" target="_self">Byone</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/10_4_bytom_spanner.html" target="_self">Bytom Spanner</a></li></ul></li><li style="height:252px;overflow:hidden" class="menu-item menu-item-level-2"><span>开发指南<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/11_1_architecture.html" target="_self">系统架构</a></li><li class="menu-item menu-item-level-3"><a target="_self">交易说明</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/11_3_mnemonic.html" target="_self">助记词</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/11_4_websocket.html" target="_self">Websocket调用节点</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/11_5_json_rpc.html" target="_self">JSON-RPC调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/11_6_sdk.html" target="_self">SDK介绍</a></li></ul></li><li style="height:180px;overflow:hidden" class="menu-item menu-item-level-2"><span>智能合约<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/12_1_equity.html" target="_self">智能合约</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/12_2_smart_contract_build.html" target="_self">智能合约构建</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/12_3_contract_template.html" target="_self">智能合约模板</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/12_4_contract_operator.html" target="_self">智能合约操作码</a></li></ul></li><li style="height:72px;overflow:hidden" class="menu-item menu-item-level-2"><span>对接指南<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/13_1_mining_pool_docking_guide.html" target="_self">矿池对接文档</a></li></ul></li><li style="height:180px;overflow:hidden" class="menu-item menu-item-level-2"><span>术语表<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/14_1_transaction.html" target="_self">交易</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/14_2_address.html" target="_self">地址</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/14_3_account.html" target="_self">账户</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/14_4_block.html" target="_self">区块</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/15_error_code.html" target="_self">错误码</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/16_faq.html" target="_self">常见问题</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/17_community.html" target="_self">社区</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h1>Tensority算法</h1>
<p><a name="61a3ec66"></a></p>
<h2>介绍</h2>
<p>Tensority 算法利用种子和区块头哈希作为输入值并产生相应的工作量。</p>
<p><a name="4b354c7e"></a></p>
<h2>算法流程</h2>
<p>Tensority算法总体分为以下几个步骤：</p>
<ol>
<li>生成seed</li>
<li>生成cache</li>
<li>构造矩阵列表</li>
<li>矩阵乘操作</li>
<li>工作量生成</li>
<li>工作量验证</li>
</ol>
<p><a name="cd225f61"></a></p>
<h3>生成seed</h3>
<p>种子 seed 是生成 cache 的输入值。<br />seed 每 256 块改变一次。第 0～256 块 (此处有 257 个块) 使用第 0 块的 block header hash，第 257～512 块使用第 256 块的 block header hash，第 513～768 块使用第 512 块的hash，以此类推。
<a name="d533908d"></a></p>
<h3>生成cache</h3>
<p>cache由seed生成，seed和cache是相互对应的关系，因此cache的产生周期也与seed相同。cache的作用就是填充256个矩阵组成的列表，因为每个矩阵行列均为256，每个元素为长度为一个字节的整型数据int8，所以cache的大小为256X256X256X1B=16777216B=16MB。生成cache算法使用的是Scrypt算法，Scrypt算法在计算过程中会产生相应的伪随机数集合，以此作为cache值。由于Scrypt算法的特点，需要输入一个128字节的seed作为输入值。因此，首先需要将2.1得到的32字节的seed值进行扩展，得到一个128字节的扩展种子extseed。之后将extseed进行循环128次Scrypt中的smix过程，将128次过程中产生的随机数集合连接起来组成cache。具体算法如Algorithm calcSeedCache.</p>
<pre><code>Algorithm: calcSeedCache
------------------------------------------------
Input: seed
Output: cache
------------------------------------------------
1   Initialize extround = 3, scryptround = 128;
2   extseed = seed;
3   tmphash = seed;
4   for i = 1; i &lt;= extround; i++ do
5       tmphash = SHA256(tmphash);
6       extseed = append(extseed, tmphash);
7   end
8   cache = null;
9   tmpv = null;
10  for j = 1; j &lt;= scryptround; j++ do
11      tmpv = Scrypt.smix(extseed, tmpv);
12      cache = append(cache, tmpv);
13  end
14  return cache
------------------------------------------------
</code></pre>
<p><a name="af7e84ff"></a></p>
<h3>构造矩阵列表</h3>
<p>16MB的cache分成128组，每一组中有32X1024个元素，每个元素值类型为uint32。每一组中，将32个元素视为一个单元，由此可以得到一个规格为32X1024X128的缓存矩阵列表tmpmatrix，每个元素为uint32。重组矩阵列表recomposedmatrix规格也与tmpmatrix相同。tmpmatrix中奇数索引的元素值与recomposedmatrix中的1至512号元素相互对应。类似，tmpmatrix中偶数索引的元素值与recomposedmatrix中的513至1024号元素相互对应。之后将之转化为规格为256X256X256的矩阵列表cachematrix，每个矩阵元素为一个字节的int8。具体算法如Algorithm constructCacheMatrix。</p>
<pre><code>Algorithm: constructCacheMatrix
------------------------------------------------------------------------------
Input: cache
Output: cachematrix
------------------------------------------------------------------------------
1   Initialize dim1 = 32; dim2 = 1024; dim3 = 128; dim = 256;
2   tmpmatrix = Matrix(cache, dim1, dim2, dim3);
3   recomposedmatrix = NewMatrix(dim1, dim2, dim3);
4   cachematrix = NewMatrix(dim, dim, dim);
5   recomposedmatrix[:][1:dim2/2][:] = tmpmatrix[:][all odd index][:];
6   recomposedmatrix[:][dim2/2+1:dim2][:] = tmpmatrix[:][all even index][:];
7   cachematrix = Float64(Matrix(Int8Array(recomposedmatrix), dim, dim, dim)));
8   return cachematrix;
------------------------------------------------------------------------------
</code></pre>
<p><a name="557aac34"></a></p>
<h3>矩阵乘操作</h3>
<p>矩阵乘之前需要生成矩阵乘的索引，将区块头哈希值分成4组，之后将每一组进行哈希运算，得到32字节的哈希值。每个字节的值正好取值为0至255，对应着256个矩阵。矩阵相乘的过程中将每个矩阵元素由int8类型转化为int32类型。相乘的中间结果是int32类型，这个时候可以将int32数值的低位两个字节相加取模256，得到一个新的值，这就完成了32位转8位的操作。两个矩阵乘相乘遵从线性代数的运算法则，左矩阵与右矩阵的转置矩阵相乘。具体算法如Algorithm constructHashMatrix。</p>
<pre><code>Algorithm: constructHashMatrix
------------------------------------------------------------------------------
Input: cachematrix, headerhash
Output: hashmatrix
------------------------------------------------------------------------------
1   Initialize drawround = 4; mulround = 2; dim = 256;
2   hashmatrix = Matrix(dim, dim);
3   drawmatrix = Matrix(headerhash, drawround, sizeof(headerhash)/drawround);
4   for i = 1; i &lt;= drawround; i++ do
5       ma = I;
6       mc = Matrix(dim, dim);
7       sequence = SHA256(drawmatrix[i]);
8       for j = 1; j &lt;= mulround; j++ do
9           for k = 1; k &lt;= sizeof(sequence); k++ do
10              index = uint8(sequence[k])+1;
11              mb = srcmatrix[index][:][:];
12              mc = ma * mb.T();
13              for element ∈ mc do
14                  element = Float64(Compress32to8(Int32(element)));
15              end
16              ma = mc
17          end
18      end
19      for row = 1; row &lt;= dim; row++ do
20          for col = 1; col &lt;= dim; col++ do
21              i32vhashmatrix = Int32(hashmatrix[row][col]);
22              i32vma = Int32(ma[row][col]);
23              i8v = Int8(i32vhashmatrix+i32vma);
24              hashmatrix[row][col] = Float64(i8v);
25          end
26      end
27  end
28  return hashmatrix;
------------------------------------------------------------------------------
</code></pre>
<p><a name="51b65e3c"></a></p>
<h3>工作量生成</h3>
<p>为了提高计算效率，生成工作量时使用FNV算法简化矩阵。因为FNV函数的特性，需要将四个元素合并组成一个uint32类型的数字，组成新的256X64的矩阵mat32，然后进行FNV简化操作。之后将简化的结果进行哈希运算。具体算法如 Algorithm <em>Binary Forwarded FNV</em>.</p>
<pre><code>Algorithm: Binary Forwarded FNV
---------------------------------------------------------------
Input: mat32
Output: hash
---------------------------------------------------------------
1   Initialize dim1 = 256; dim2 = 64;
2   for k = dim1; k &gt; 1; k = k/2 do
3       for i = 1; i &lt;= k; i++ do
4           for j = 1; j &lt;= dim2; j++ do
5               mat32[i][j] = FNV(mat32[i][j], mat32[i+k][j]);
6           end
7       end
8   end
9   hash = SHA256(ToByteArray(mat32[0][:]);
10  return hash;
---------------------------------------------------------------
</code></pre>
<p><a name="dcc03bf7"></a></p>
<h3>工作量验证</h3>
<p>将2.5得到的哈希值与区块要求的难度值相比较，小于规定值则说明挖矿成功，否则更换随机数重新生成区块头，开始新的计算。</p>
<p><a name="884a7b7f"></a></p>
<h2>随机性分析</h2>
<p>可以参考<a href="https://github.com/Bytom/bytom/wiki/download/tensority-v1.2.pdf">Tensority算法白皮书</a>。</p>
</div></section><footer class="footer-container"><div class="footer-body"><div class="copyright"><span>Copyright © 2019 Bytom</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>