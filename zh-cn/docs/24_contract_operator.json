{
  "filename": "24_contract_operator.md",
  "__html": "<h1>常见数值操作码</h1>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_1ADD</td>\n<td>0x8b</td>\n<td>返回栈顶数据加1</td>\n</tr>\n<tr>\n<td>OP_1SUB</td>\n<td>0x8c</td>\n<td>返回栈顶数据减1</td>\n</tr>\n<tr>\n<td>OP_2MUL</td>\n<td>0x8d</td>\n<td>返回栈顶数据乘2</td>\n</tr>\n<tr>\n<td>OP_2DIV</td>\n<td>0x8e</td>\n<td>返回栈顶数据除2</td>\n</tr>\n<tr>\n<td>OP_NEGATE</td>\n<td>0x8f</td>\n<td>返回栈顶数据符号取反结果</td>\n</tr>\n<tr>\n<td>OP_ABS</td>\n<td>0x90</td>\n<td>返回栈顶数据符号取正结果</td>\n</tr>\n<tr>\n<td>OP_NOT</td>\n<td>0x91</td>\n<td>判断输入值是否为0，如果为0则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_0NOTEQUAL</td>\n<td>0x92</td>\n<td>判断输入值是否不为0，如果不为0则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_ADD</td>\n<td>0x93</td>\n<td>返回两个输入值之和</td>\n</tr>\n<tr>\n<td>OP_SUB</td>\n<td>0x94</td>\n<td>返回两个输入值之差，即x-y，其中两个输入值的顺序为y、x</td>\n</tr>\n<tr>\n<td>OP_MUL</td>\n<td>0x95</td>\n<td>返回两个输入值之积</td>\n</tr>\n<tr>\n<td>OP_DIV</td>\n<td>0x96</td>\n<td>返回两个输入值相除的结果，即x/y，其中两个输入值的顺序为y、x</td>\n</tr>\n<tr>\n<td>OP_MOD</td>\n<td>0x97</td>\n<td>返回两个输入值取余的结果，即x mod y，其中两个输入值的顺序为y、x</td>\n</tr>\n<tr>\n<td>OP_LSHIFT</td>\n<td>0x98</td>\n<td>返回左移位结果，表示y向左移动x位，即 y &lt;&lt; uint(x)，其中第一个输入值表示移位系数x，第二个输入值表示操作数y</td>\n</tr>\n<tr>\n<td>OP_RSHIFT</td>\n<td>0x99</td>\n<td>返回右移位结果，表示y向右移动x位，即 y &gt;&gt; uint(x)，其中第一个输入值表示移位系数x，第二个输入值表示操作数y</td>\n</tr>\n<tr>\n<td>OP_BOOLAND</td>\n<td>0x9a</td>\n<td>布尔类型逻辑与操作，即两个输入值都为非零时返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_BOOLOR</td>\n<td>0x9b</td>\n<td>布尔类型逻辑或操作，即两个输入值至少有一个为非零时返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_NUMEQUAL</td>\n<td>0x9c</td>\n<td>判断两个整型输入值是否相等，如果相等则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_NUMEQUALVERIFY</td>\n<td>0x9d</td>\n<td>先执行OP_NUMEQUAL操作，然后再执行OP_VERIFY操作，即两个整型输入值相等时，返回nil（VERIFY成功），否则VERIFY失败</td>\n</tr>\n<tr>\n<td>OP_NUMNOTEQUAL</td>\n<td>0x9e</td>\n<td>判断两个整型输入值是否不相等，如果不相等则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_LESSTHAN</td>\n<td>0x9f</td>\n<td>两个输入值的顺序为x、y，如果 y&lt;x 则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_GREATERTHAN</td>\n<td>0xa0</td>\n<td>两个输入值的顺序为x、y，如果 y&gt;x 则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_LESSTHANOREQUAL</td>\n<td>0xa1</td>\n<td>两个输入值的顺序为x、y，如果 y&lt;=x 则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_GREATERTHANOREQUAL</td>\n<td>0xa2</td>\n<td>两个输入值的顺序为x、y，如果 y&gt;=x 则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_MIN</td>\n<td>0xa3</td>\n<td>返回两个栈顶数值中较小的一项</td>\n</tr>\n<tr>\n<td>OP_MAX</td>\n<td>0xa4</td>\n<td>返回两个栈顶数值中较大的一项</td>\n</tr>\n<tr>\n<td>OP_WITHIN</td>\n<td>0xa5</td>\n<td>三个输入值的顺序为x、y、z，如果 y &lt;= z &lt;= x 则返回true，否则返回fale</td>\n</tr>\n</tbody>\n</table>\n<h1>位操作码</h1>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_INVERT</td>\n<td>0x83</td>\n<td>返回输入值按位取反的运算结果</td>\n</tr>\n<tr>\n<td>OP_AND</td>\n<td>0x84</td>\n<td>返回输入值按位逻辑与运算</td>\n</tr>\n<tr>\n<td>OP_OR</td>\n<td>0x85</td>\n<td>返回输入值按位逻辑或运算</td>\n</tr>\n<tr>\n<td>OP_XOR</td>\n<td>0x86</td>\n<td>返回输入值按位逻辑异或运算</td>\n</tr>\n<tr>\n<td>OP_EQUAL</td>\n<td>0x87</td>\n<td>判断两个输入值是否相等，如果相等则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_EQUALVERIFY</td>\n<td>0x88</td>\n<td>先执行OP_EQUAL操作，然后再执行OP_VERIFY操作，即两个输入值相等时，返回nil（VERIFY成功），否则VERIFY失败</td>\n</tr>\n</tbody>\n</table>\n<h1>字符串处理操作码</h1>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_CAT</td>\n<td>0x7e</td>\n<td>返回连接两个字符串的结果，输入字符串的顺序为a、b，返回结果为 ab</td>\n</tr>\n<tr>\n<td>OP_SUBSTR</td>\n<td>0x7f</td>\n<td>返回从指定偏移量开始截取固定长度的字符串子集，输入值的顺序为size、offset、str，返回结果为从str字符串的offset位置截取size大小的字符串子集。输入大小2，offset=c，str=abdcfghk，返回结果为fg</td>\n</tr>\n<tr>\n<td>OP_LEFT</td>\n<td>0x80</td>\n<td>返回截取字符串左边指定长度的子串，输入值的顺序为size、str，返回结果为截取str字符串左边size大小的字符串子集。输入size=3，str=hello，返回结果为hel</td>\n</tr>\n<tr>\n<td>OP_RIGHT</td>\n<td>0x81</td>\n<td>返回截取字符串右边指定长度的子串，输入值的顺序为size、str，返回结果为截取str字符串右边size大小的字符串子集。输入size=3，str=hello，返回结果为llo</td>\n</tr>\n<tr>\n<td>OP_SIZE</td>\n<td>0x82</td>\n<td>返回字符串的长度大小，即len(str)</td>\n</tr>\n<tr>\n<td>OP_CATPUSHDATA</td>\n<td>0x89</td>\n<td>返回连接两个[]byte数据结果，输入数据的顺序为a、b，返回结果为 append(b, a)</td>\n</tr>\n</tbody>\n</table>\n<h1>加密和散列操作码</h1>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_SHA256</td>\n<td>0xa8</td>\n<td>返回输入项的sha256哈希值</td>\n</tr>\n<tr>\n<td>OP_SHA3</td>\n<td>0xaa</td>\n<td>返回输入项的sha3哈希值</td>\n</tr>\n<tr>\n<td>OP_HASH160</td>\n<td>0xab</td>\n<td>返回输入项的Ripemd160哈希值</td>\n</tr>\n<tr>\n<td>OP_CHECKSIG</td>\n<td>0xac</td>\n<td>验证交易签名是否正确，如果验证成功则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_CHECKMULTISIG</td>\n<td>0xad</td>\n<td>依次验证每个签名和公钥对是否正确，如果所有的签名和公钥对都验证成功则返回true，否则返回false</td>\n</tr>\n<tr>\n<td>OP_TXSIGHASH</td>\n<td>0xae</td>\n<td>返回交易签名哈希，即虚拟机中context的TxSigHash</td>\n</tr>\n</tbody>\n</table>\n<h1>控制流程操作码</h1>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_JUMP</td>\n<td>0x63</td>\n<td>无条件跳转到堆栈的指定位置，将PC设置为栈顶的四字节小端存储的无符号整数地址。如果该值不存在则执行失败</td>\n</tr>\n<tr>\n<td>OP_JUMPIF</td>\n<td>0x64</td>\n<td>条件跳转到堆栈的指定位置，跟OP_JUMP的区别在于该操作从数据堆栈中取出一个boolean值，如果为true才把PC设置到该地址，如果为false则不进行任何操作</td>\n</tr>\n<tr>\n<td>OP_VERIFY</td>\n<td>0x69</td>\n<td>校验数据堆栈的栈顶的结果，如果为true，则删除栈顶元素，并返回nil，否则执行失败</td>\n</tr>\n<tr>\n<td>OP_FAIL</td>\n<td>0x6a</td>\n<td>无条件执行失败</td>\n</tr>\n<tr>\n<td>OP_CHECKPREDICATE</td>\n<td>0xc0</td>\n<td>调用子虚拟机执行对应的program，如果执行成功则返回true，否则返回false。如果VM的运行限制小于256，则立即执行失败</td>\n</tr>\n</tbody>\n</table>\n<h1>堆栈控制操作码</h1>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_TOALTSTACK</td>\n<td>0x6b</td>\n<td>把主堆栈的栈顶元素压入辅堆栈顶部，从主堆栈删除</td>\n</tr>\n<tr>\n<td>OP_FROMALTSTACK</td>\n<td>0x6c</td>\n<td>把辅堆栈的栈顶元素压入主堆栈顶部，从辅堆栈删除。如果辅堆栈为空则执行失败</td>\n</tr>\n<tr>\n<td>OP_2DROP</td>\n<td>0x6d</td>\n<td>删除栈顶两个元素</td>\n</tr>\n<tr>\n<td>OP_2DUP</td>\n<td>0x6e</td>\n<td>复制栈顶两个元素</td>\n</tr>\n<tr>\n<td>OP_3DUP</td>\n<td>0x6f</td>\n<td>复制栈顶三个元素</td>\n</tr>\n<tr>\n<td>OP_2OVER</td>\n<td>0x70</td>\n<td>把栈底的两个元素复制到栈顶</td>\n</tr>\n<tr>\n<td>OP_2ROT</td>\n<td>0x71</td>\n<td>将数据堆栈中的第五和第六个元素移动到栈顶。</td>\n</tr>\n<tr>\n<td>OP_2SWAP</td>\n<td>0x72</td>\n<td>将数据堆栈中的第三第四个元素移动到栈顶</td>\n</tr>\n<tr>\n<td>OP_IFDUP</td>\n<td>0x73</td>\n<td>当数据堆栈的栈顶不是false时进行复制栈顶</td>\n</tr>\n<tr>\n<td>OP_DEPTH</td>\n<td>0x74</td>\n<td>把数据堆栈的元素个数压入堆栈</td>\n</tr>\n<tr>\n<td>OP_DROP</td>\n<td>0x75</td>\n<td>从数据堆栈中删除栈顶元素</td>\n</tr>\n<tr>\n<td>OP_DUP</td>\n<td>0x76</td>\n<td>复制数据堆栈的栈顶元素</td>\n</tr>\n<tr>\n<td>OP_NIP</td>\n<td>0x77</td>\n<td>删除栈顶的下一个元素</td>\n</tr>\n<tr>\n<td>OP_OVER</td>\n<td>0x78</td>\n<td>复制数据堆栈的栈顶下一个元素到栈顶</td>\n</tr>\n<tr>\n<td>OP_PICK</td>\n<td>0x79</td>\n<td>将数据堆栈的第n个元素复制到栈顶</td>\n</tr>\n<tr>\n<td>OP_ROLL</td>\n<td>0x7a</td>\n<td>将数据堆栈的第n个元素移动到栈顶</td>\n</tr>\n<tr>\n<td>OP_ROT</td>\n<td>0x7b</td>\n<td>将数据堆栈中的第三个元素向左翻转</td>\n</tr>\n<tr>\n<td>OP_SWAP</td>\n<td>0x7c</td>\n<td>数据堆栈中栈顶的两个元素交换</td>\n</tr>\n<tr>\n<td>OP_TUCK</td>\n<td>0x7d</td>\n<td>从数据堆栈中栈顶元素复制并插入到栈顶下一个元素后面</td>\n</tr>\n</tbody>\n</table>\n<h1>VM检查操作码</h1>\n<p>这些指令会导致VM立即停止并返回false 。</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_CHECKOUTPUT</td>\n<td>0xc1</td>\n<td>从数据堆栈中弹出5项进行检查：prog，version，assetid，amount，index</td>\n</tr>\n<tr>\n<td>OP_ASSET</td>\n<td>0xc2</td>\n<td>这条指令已经删掉了Nonce类型）返回资产ID（assetid），即虚拟机中context的AssetID。校验context的资产ID，主要有两种情况：1）如果第一个action对象是Issuance，则直接推送value.AssetID;2）如果第一个action对象是Spend，则推送SpentOutput.Source.Value.AssetID</td>\n</tr>\n<tr>\n<td>OP_AMOUNT</td>\n<td>0xc3</td>\n<td>这条指令已经删掉了Nonce类型）返回资产数量（amount），即虚拟机中context的Amount。校验context的资产数量，主要有两种情况：1）如果第一个action对象是Issuance，则直接推送value.Amount; 2）如果第一个action对象是Spend，则推送SpentOutput.Source.Value.Amount</td>\n</tr>\n<tr>\n<td>OP_PROGRAM</td>\n<td>0xc4</td>\n<td>返回接收的program，即虚拟机中context的Code</td>\n</tr>\n<tr>\n<td>OP_INDEX</td>\n<td>0xc9</td>\n<td>返回目标接收对象的索引位置，即虚拟机中context的DestPos</td>\n</tr>\n<tr>\n<td>OP_ENTRYID</td>\n<td>0xca</td>\n<td>返回目标接收对象的交易entryID，即虚拟机中context的EntryID</td>\n</tr>\n<tr>\n<td>OP_OUTPUTID</td>\n<td>0xcb</td>\n<td>返回已花费UTXO生成的交易SpentOutputID，即虚拟机中context的SpentOutputID</td>\n</tr>\n<tr>\n<td>OP_BLOCKHEIGHT</td>\n<td>0xcd</td>\n<td>返回当前块的高度height，即虚拟机中context的BlockHeight</td>\n</tr>\n</tbody>\n</table>\n<h1>数据入栈操作指令</h1>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>代码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OP_PUSHDATA1</td>\n<td>0x4c</td>\n<td>将一个字节的数据长度前缀和对应长度大小的字节数据压入堆栈，即(prefix + data)，其中prefix=len(data)，而前缀prefix所能表示的范围为:(0, 255)bytes，对应的十六进制范围为:(0x00, 0xFF)</td>\n</tr>\n<tr>\n<td>OP_PUSHDATA2</td>\n<td>0x4d</td>\n<td>将两个字节的数据长度前缀和对应长度大小的字节数据压入堆栈，即(prefix + data)，其中prefix=len(data)，而前缀prefix所能表示的范围为:(0, 65535)bytes，对应的十六进制范围为:(0x0000, 0xFFFF)</td>\n</tr>\n<tr>\n<td>OP_PUSHDATA4</td>\n<td>0x4e</td>\n<td>将四个字节的数据长度前缀和对应长度大小的字节数据压入堆栈，即(prefix + data)，其中prefix=len(data)，而前缀prefix所能表示的范围为:(0, 4294967295)bytes，对应的十六进制范围为:(0x00000000, 0xFFFFFFFF)</td>\n</tr>\n<tr>\n<td>OP_1NEGATE</td>\n<td>0x4f</td>\n<td>数字 -1 被压入堆栈</td>\n</tr>\n<tr>\n<td>OP_NOP</td>\n<td>0x61</td>\n<td>无任何操作</td>\n</tr>\n<tr>\n<td>OP_FALSE / OP_0</td>\n<td>0x00</td>\n<td>一个字节空串被推到堆栈中（并非OP_NOP操作，这里会有一个元素被压入堆栈）</td>\n</tr>\n<tr>\n<td>OP_TRUE</td>\n<td>0x51</td>\n<td>数字 1 被压入堆栈</td>\n</tr>\n<tr>\n<td>OP_1 ~ OP_16</td>\n<td>0x51 ~ 0x60</td>\n<td>数字 n 被压入堆栈，n的取值范围为[1, 16]</td>\n</tr>\n<tr>\n<td>OP_DATA_1 ~ OP_DATA_75</td>\n<td>0x01 ~ 0x4b</td>\n<td>把 n 个字节大小的数据压入堆栈， n的取值范围为[1, 75]</td>\n</tr>\n</tbody>\n</table>\n",
  "link": "/zh-cn/docs/24_contract_operator.html",
  "meta": {}
}