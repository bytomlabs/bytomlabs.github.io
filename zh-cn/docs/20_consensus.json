{
  "filename": "20_consensus.md",
  "__html": "<h1>1. AI-PoW 介绍</h1>\n<p>Tensority 算法利用种子和区块头哈希作为输入值并产生相应的工作量。</p>\n<h1>2. 算法流程</h1>\n<p>Tensority算法总体分为以下几个步骤：</p>\n<ol>\n<li>生成seed</li>\n<li>生成cache</li>\n<li>构造矩阵列表</li>\n<li>矩阵乘操作</li>\n<li>工作量生成</li>\n<li>工作量验证</li>\n</ol>\n<h2>2.1. 生成seed</h2>\n<p>种子 seed 是生成 cache 的输入值。</p>\n<p>seed 每 256 块改变一次。第 0～256 块 (此处有 257 个块) 使用第 0 块的 block header hash，第 257～512 块使用第 256 块的 block header hash，第 513～768 块使用第 512 块的hash，以此类推。</p>\n<h2>2.2. 生成cache</h2>\n<p>cache由seed生成，seed和cache是相互对应的关系，因此cache的产生周期也与seed相同。cache的作用就是填充256个矩阵组成的列表，因为每个矩阵行列均为256，每个元素为长度为一个字节的整型数据int8，所以cache的大小为256X256X256X1B=16777216B=16MB。生成cache算法使用的是Scrypt算法，Scrypt算法在计算过程中会产生相应的伪随机数集合，以此作为cache值。由于Scrypt算法的特点，需要输入一个128字节的seed作为输入值。因此，首先需要将2.1得到的32字节的seed值进行扩展，得到一个128字节的扩展种子extseed。之后将extseed进行循环128次Scrypt中的smix过程，将128次过程中产生的随机数集合连接起来组成cache。具体算法如Algorithm calcSeedCache.</p>\n<pre><code class=\"language-txt\">Algorithm: calcSeedCache\n------------------------------------------------\nInput: seed\nOutput: cache\n------------------------------------------------\n1   Initialize extround = 3, scryptround = 128;\n2   extseed = seed;\n3   tmphash = seed;\n4   for i = 1; i &lt;= extround; i++ do\n5       tmphash = SHA256(tmphash);\n6       extseed = append(extseed, tmphash);\n7   end\n8   cache = null;\n9   tmpv = null;\n10  for j = 1; j &lt;= scryptround; j++ do\n11      tmpv = Scrypt.smix(extseed, tmpv);\n12      cache = append(cache, tmpv);\n13  end\n14  return cache\n------------------------------------------------\n</code></pre>\n<h2>2.3. 构造矩阵列表</h2>\n<p>16MB的cache分成128组，每一组中有32X1024个元素，每个元素值类型为uint32。每一组中，将32个元素视为一个单元，由此可以得到一个规格为32X1024X128的缓存矩阵列表tmpmatrix，每个元素为uint32。重组矩阵列表recomposedmatrix规格也与tmpmatrix相同。tmpmatrix中奇数索引的元素值与recomposedmatrix中的1至512号元素相互对应。类似，tmpmatrix中偶数索引的元素值与recomposedmatrix中的513至1024号元素相互对应。之后将之转化为规格为256X256X256的矩阵列表cachematrix，每个矩阵元素为一个字节的int8。具体算法如Algorithm constructCacheMatrix。</p>\n<pre><code class=\"language-txt\">Algorithm: constructCacheMatrix\n------------------------------------------------------------------------------\nInput: cache\nOutput: cachematrix\n------------------------------------------------------------------------------\n1   Initialize dim1 = 32; dim2 = 1024; dim3 = 128; dim = 256;\n2   tmpmatrix = Matrix(cache, dim1, dim2, dim3);\n3   recomposedmatrix = NewMatrix(dim1, dim2, dim3);\n4   cachematrix = NewMatrix(dim, dim, dim);\n5   recomposedmatrix[:][1:dim2/2][:] = tmpmatrix[:][all odd index][:];\n6   recomposedmatrix[:][dim2/2+1:dim2][:] = tmpmatrix[:][all even index][:];\n7   cachematrix = Float64(Matrix(Int8Array(recomposedmatrix), dim, dim, dim)));\n8   return cachematrix;\n------------------------------------------------------------------------------\n</code></pre>\n<h2>2.4. 矩阵乘操作</h2>\n<p>矩阵乘之前需要生成矩阵乘的索引，将区块头哈希值分成4组，之后将每一组进行哈希运算，得到32字节的哈希值。每个字节的值正好取值为0至255，对应着256个矩阵。矩阵相乘的过程中将每个矩阵元素由int8类型转化为int32类型。相乘的中间结果是int32类型，这个时候可以将int32数值的低位两个字节相加取模256，得到一个新的值，这就完成了32位转8位的操作。两个矩阵乘相乘遵从线性代数的运算法则，左矩阵与右矩阵的转置矩阵相乘。具体算法如Algorithm constructHashMatrix。</p>\n<pre><code class=\"language-txt\">Algorithm: constructHashMatrix\n------------------------------------------------------------------------------\nInput: cachematrix, headerhash\nOutput: hashmatrix\n------------------------------------------------------------------------------\n1   Initialize drawround = 4; mulround = 2; dim = 256;\n2   hashmatrix = Matrix(dim, dim);\n3   drawmatrix = Matrix(headerhash, drawround, sizeof(headerhash)/drawround);\n4   for i = 1; i &lt;= drawround; i++ do\n5       ma = I;\n6       mc = Matrix(dim, dim);\n7       sequence = SHA256(drawmatrix[i]);\n8       for j = 1; j &lt;= mulround; j++ do\n9           for k = 1; k &lt;= sizeof(sequence); k++ do\n10              index = uint8(sequence[k])+1;\n11              mb = srcmatrix[index][:][:];\n12              mc = ma * mb.T();\n13              for element ∈ mc do\n14                  element = Float64(Compress32to8(Int32(element)));\n15              end\n16              ma = mc\n17          end\n18      end\n19      for row = 1; row &lt;= dim; row++ do\n20          for col = 1; col &lt;= dim; col++ do\n21              i32vhashmatrix = Int32(hashmatrix[row][col]);\n22              i32vma = Int32(ma[row][col]);\n23              i8v = Int8(i32vhashmatrix+i32vma);\n24              hashmatrix[row][col] = Float64(i8v);\n25          end\n26      end\n27  end\n28  return hashmatrix;\n------------------------------------------------------------------------------\n</code></pre>\n<h2>2.5. 工作量生成</h2>\n<p>为了提高计算效率，生成工作量时使用FNV算法简化矩阵。因为FNV函数的特性，需要将四个元素合并组成一个uint32类型的数字，组成新的256X64的矩阵mat32，然后进行FNV简化操作。之后将简化的结果进行哈希运算。具体算法如 Algorithm <em>Binary Forwarded FNV</em>.</p>\n<pre><code class=\"language-txt\">Algorithm: Binary Forwarded FNV\n---------------------------------------------------------------\nInput: mat32\nOutput: hash\n---------------------------------------------------------------\n1   Initialize dim1 = 256; dim2 = 64;\n2   for k = dim1; k &gt; 1; k = k/2 do\n3       for i = 1; i &lt;= k; i++ do\n4           for j = 1; j &lt;= dim2; j++ do\n5               mat32[i][j] = FNV(mat32[i][j], mat32[i+k][j]);\n6           end\n7       end\n8   end\n9   hash = SHA256(ToByteArray(mat32[0][:]);\n10  return hash;\n---------------------------------------------------------------\n</code></pre>\n<h2>2.6. 工作量验证</h2>\n<p>将2.5得到的哈希值与区块要求的难度值相比较，小于规定值则说明挖矿成功，否则更换随机数重新生成区块头，开始新的计算。</p>\n<h1>3. 随机性分析</h1>\n<p>可以参考<a href=\"https://github.com/Bytom/bytom/wiki/download/tensority-v1.2.pdf\">Tensority算法白皮书</a>。</p>\n",
  "link": "/zh-cn/docs/20_consensus.html",
  "meta": {}
}